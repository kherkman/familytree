<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Tree Maker</title>
    <!-- dom-to-image for Save to JPG functionality -->
    <script src="https://cdn.jsdelivr.net/npm/dom-to-image@2.6.0/dist/dom-to-image.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a; /* Dark background */
            color: #f0f0f0; /* Light text */
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #ffa500; /* Orange for title */
        }

        .controls {
            background-color: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 800px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }

        .controls input[type="text"],
        .controls input[type="number"],
        .controls select {
            padding: 10px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #444;
            color: #f0f0f0;
            font-size: 1em;
            width: 180px; /* Adjust width as needed */
        }

        .controls input[type="range"] {
            -webkit-appearance: none;
            width: 150px;
            height: 8px;
            background: #555;
            outline: none;
            border-radius: 4px;
        }

        .controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffa500;
            cursor: grab;
            border: 2px solid #333;
        }

        .controls input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffa500;
            cursor: grab;
            border: 2px solid #333;
        }

        .controls input[type="text"]::placeholder,
        .controls input[type="number"]::placeholder {
            color: #bbb;
        }

        .controls button {
            background-color: #ffa500; /* Orange button */
            color: #1a1a1a;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .controls button:hover:not(:disabled) {
            background-color: #e69500;
        }
        
        .controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
            color: #bbb;
        }

        .tree-container {
            background-color: #2b2b2b;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
            overflow: auto; /* Enable scrolling if content overflows */
            width: 90%;
            max-width: 1000px;
            min-height: 500px; /* Ensure some visibility */
            position: relative; /* For tooltip positioning */
            background-repeat: no-repeat;
            background-size: 100%;
            background-position: 0% 0%;
        }

        svg {
            width: 100%;
            height: auto;
            min-height: 500px;
            display: block;
            user-select: none; /* Prevent text selection during drag */
            transition: transform 0.3s ease-in-out; /* Smooth rotation and scaling */
            transform-origin: center center; /* Rotate and scale around its center */
        }

        .person-node rect {
            fill: #444;
            stroke: #ffa500;
            stroke-width: 2;
            rx: 5;
            ry: 5;
            transition: stroke-width 0.2s ease, stroke 0.2s ease;
            cursor: grab; /* Indicate draggable */
        }

        .person-node.dragging rect {
            cursor: grabbing;
        }

        .person-node.selected rect {
            stroke: #00bfff; /* Highlight selected node with blue */
            stroke-width: 3;
        }

        .person-node text {
            fill: #f0f0f0;
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none; /* Allow click/drag to pass to the group */
        }
        
        .person-node .name-text {
            dominant-baseline: central; /* Align text vertically in the middle of its line */
        }


        .person-node .node-image {
            object-fit: cover; /* Cover the area */
            stroke: #ffa500;
            stroke-width: 1;
            border-radius: 50%; /* Make images round */
            pointer-events: none; /* Allow click/drag to pass to the group */
        }

        .person-line {
            stroke: #ffa500;
            stroke-width: 2;
            fill: none;
        }

        .lifeline {
            stroke: #8a2be2; /* Purple color for lifeline */
            stroke-width: 2;
            fill: none;
        }

        .year-line {
            stroke: #777;
            stroke-width: 1;
            stroke-dasharray: 4 2;
        }

        .year-label {
            fill: #f0f0f0;
            font-size: 12px;
            text-anchor: end;
        }

        .hidden-file-input {
            display: none;
        }

        .tooltip {
            position: absolute;
            background-color: #333;
            color: #f0f0f0;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none; /* Allows clicks to pass through to elements below */
            opacity: 0;
            transition: opacity 0.2s ease;
            white-space: nowrap;
            z-index: 10;
            border: 1px solid #ffa500;
            font-size: 13px;
            transform: translateX(-50%); /* Center horizontally */
        }

        .tooltip.visible {
            opacity: 1;
        }

        .zoom-label {
            color: #f0f0f0;
            font-size: 0.9em;
            margin-left: 10px;
            min-width: 30px; /* Ensure space for current zoom value */
            text-align: right;
        }

        /* Message Box Styling */
        #messageBox {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.1); /* Slightly transparent white */
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 100;
            pointer-events: none; /* Ensure it doesn't block interactions */
        }

        #messageBox.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <h1>Family Tree Maker</h1>

    <div class="controls">
        <input type="text" id="personName" placeholder="Name" required>
        <input type="number" id="birthYear" placeholder="Birth Year" min="-100000" max="100000">
        <input type="number" id="deathYear" placeholder="Death Year (optional)" min="-100000" max="100000">
        <select id="parent1Select">
            <option value="">Parent 1 (None)</option>
        </select>
        <select id="parent2Select">
            <option value="">Parent 2 (None)</option>
        </select>
        <button id="addUpdateBtn" onclick="addUpdatePerson()">Add Person</button>
        <button onclick="exportToCsv()">Export to CSV</button>
        <input type="file" id="importCsvFile" accept=".csv" class="hidden-file-input" onchange="importFromCsv()">
        <button onclick="document.getElementById('importCsvFile').click()">Import from CSV</button>
        
        <!-- Image URL Input & Button -->
        <input type="text" id="imageUrlInput" placeholder="Image URL">
        <button id="linkImageBtn" onclick="linkImage()" disabled>Link Image</button>

        <input type="file" id="imageFileInput" accept="image/*" class="hidden-file-input" onchange="handleImageUpload()">
        <button id="loadImageBtn" onclick="document.getElementById('imageFileInput').click()" disabled>Load Image</button>
        <button id="removeImageBtn" onclick="removeImage()" disabled>Remove Image</button>

        <button onclick="saveAsJpg()">Save to JPG</button>
        
        <label for="zoomSlider">Zoom:</label>
        <input type="range" id="zoomSlider" min="1" max="10" value="3" step="0.5" onchange="updateZoom()" oninput="updateZoom()">
        <span id="currentZoom" class="zoom-label">3.0x</span>
        
        <label for="imageSizeInput">Image Size:</label>
        <input type="range" id="imageSizeInput" min="10" max="100" value="40" step="5" onchange="updateImageSize()" oninput="updateImageSize()">
        <span id="currentImageSize" class="zoom-label">40px</span>

        <button onclick="toggleLifelines()">Toggle Lifelines</button>
        <button onclick="rotateTree()">Rotate Tree</button>
        <button id="removePersonBtn" onclick="removePerson()" disabled>Remove Person</button>
        <button onclick="toggleYearLines()">Toggle Year Lines</button>
        <!-- Dropdown for example families -->
        <select id="exampleFamilySelect" onchange="loadFamilyFromSelectedExample()">
            <option value="">Load Example Family</option>
            <option value="cleopatra_family.csv">Cleopatra</option>
            <option value="queen_victoria_family.csv">Queen Victoria</option>
            <option value="asgard_family.csv">Asgard</option>
        </select>
        <button onclick="clearTree()">Clear Tree</button>

        <!-- Tree Scale Slider -->
        <label for="treeScaleSlider">Tree Scale:</label>
        <input type="range" id="treeScaleSlider" min="0.5" max="2.0" value="1.0" step="0.1" onchange="updateTreeScale()" oninput="updateTreeScale()">
        <span id="currentTreeScale" class="zoom-label">1.0x</span>

        <!-- Background Image Controls -->
        <input type="file" id="bgImageFileInput" accept="image/*" class="hidden-file-input" onchange="handleBackgroundUpload()">
        <button onclick="document.getElementById('bgImageFileInput').click()">Add Background Image</button>
        <button id="removeBgImageBtn" onclick="removeBackgroundImage()" disabled>Remove Background Image</button>
        
        <label for="bgSizeSlider">BG Size:</label>
        <input type="range" id="bgSizeSlider" min="10" max="200" value="100" step="5" onchange="updateBackgroundStyle()" oninput="updateBackgroundStyle()">
        <span id="currentBgSize" class="zoom-label">100%</span>
        
        <label for="bgPosXSlider">BG Pos X:</label>
        <input type="range" id="bgPosXSlider" min="-200" max="200" value="0" step="1" onchange="updateBackgroundStyle()" oninput="updateBackgroundStyle()">
        <span id="currentBgPosX" class="zoom-label">0%</span>
        
        <label for="bgPosYSlider">BG Pos Y:</label>
        <input type="range" id="bgPosYSlider" min="-200" max="200" value="0" step="1" onchange="updateBackgroundStyle()" oninput="updateBackgroundStyle()">
        <span id="currentBgPosY" class="zoom-label">0%</span>
    </div>

    <div class="tree-container">
        <svg id="familyTreeSvg"></svg>
        <div id="tooltip" class="tooltip"></div>
    </div>
    <div id="messageBox"></div>

    <script>
        let family = []; // Array to store person objects
        let nextPersonId = 1;
        let selectedPersonId = null; // Stores the ID of the currently selected person
        let showLifelines = false; // Controls lifeline visibility
        let showYearLines = true; // Controls year line visibility

        // Drag & Drop variables
        let isDragging = false;
        let draggedPersonId = null;
        let initialMouseX;
        let dragOffsetX = 0; // Stores the offset from node's left edge to mouse click point
        let draggedSvgGroup = null; // Reference to the SVG 'g' element being dragged

        // Rotation and Scaling variables
        let rotationAngle = 0; // In degrees, for CSS transform
        let treeScale = 1.0; // Scale factor for the entire tree

        // Configuration for SVG drawing
        const NODE_WIDTH = 180; // Changed from 120 to 180 for more text space
        const MIN_NODE_HEIGHT = 60; // Minimum height for nodes
        let imageSize = 40; // Initial size for the person's image, now variable
        let pixelsPerYear = 3; // Initial pixels per year, controlled by slider
        const YEAR_LINE_INTERVAL = 10; // Every 10 years
        const HORIZONTAL_SPACING = 30; // Horizontal space between nodes at the same approximate year level
        let TOP_PADDING = imageSize + 10; // Space above the earliest year for images and margin (now dynamic)
        const LIFELINE_OFFSET = 5; // Horizontal offset for the lifeline from the node's right edge

        // Background image variables
        let backgroundImageUrl = null;
        let backgroundSize = 100; // in percentage
        let backgroundPosX = 0;   // in percentage
        let backgroundPosY = 0;   // in percentage

        function generateId() {
            return 'p' + (nextPersonId++);
        }

        // Show temporary message function
        function showMessage(message) {
            const msgBox = document.getElementById('messageBox');
            msgBox.textContent = message;
            msgBox.classList.add('visible');
            setTimeout(() => {
                msgBox.classList.remove('visible');
            }, 3000); // Hide after 3 seconds
        }

        function clearTree() {
            family = [];
            nextPersonId = 1;
            selectedPersonId = null;
            updateParentSelect();
            drawFamilyTree();
            resetFormAndSelection();
            document.getElementById('exampleFamilySelect').value = ""; // Reset dropdown
            showMessage('Tree cleared.');
        }

        function updateParentSelect() {
            const parent1Select = document.getElementById('parent1Select');
            const parent2Select = document.getElementById('parent2Select');
            parent1Select.innerHTML = '<option value="">Parent 1 (None)</option>'; // Clear existing options
            parent2Select.innerHTML = '<option value="">Parent 2 (None)</option>'; // Clear existing options

            family.forEach(person => {
                // Don't let a person be their own parent in the dropdown
                if (person.id !== selectedPersonId) {
                    const option1 = document.createElement('option');
                    option1.value = person.id;
                    option1.textContent = `${person.name} (${person.birthYear})`;
                    parent1Select.appendChild(option1);

                    const option2 = document.createElement('option');
                    option2.value = person.id;
                    option2.textContent = `${person.name} (${person.birthYear})`;
                    parent2Select.appendChild(option2);
                }
            });

            // If we are editing, ensure the current parents are selected
            if (selectedPersonId) {
                const personToEdit = family.find(p => p.id === selectedPersonId);
                if (personToEdit) {
                    parent1Select.value = personToEdit.parent1Id || '';
                    parent2Select.value = personToEdit.parent2Id || '';
                }
            }
        }

        function addUpdatePerson() {
            const name = document.getElementById('personName').value.trim();
            const birthYear = parseInt(document.getElementById('birthYear').value);
            const deathYearInput = document.getElementById('deathYear').value;
            const deathYear = deathYearInput ? parseInt(deathYearInput) : null;
            const parent1Id = document.getElementById('parent1Select').value || null;
            const parent2Id = document.getElementById('parent2Select').value || null;


            if (!name || isNaN(birthYear)) {
                alert('Please enter a name and valid birth year.');
                return;
            }
            if (deathYear && birthYear >= deathYear) {
                alert('Birth year must be before death year.');
                return;
            }
            // Check for a person being their own parent
            if (selectedPersonId && (parent1Id === selectedPersonId || parent2Id === selectedPersonId)) {
                alert("A person cannot be their own direct parent.");
                return;
            }
            // Prevent same person selected as both parents
            if (parent1Id && parent2Id && parent1Id === parent2Id) {
                alert("Cannot select the same person for both Parent 1 and Parent 2.");
                return;
            }

            // Basic check for circular parentage (single level for simplicity)
            if (selectedPersonId) {
                const currentPerson = family.find(p => p.id === selectedPersonId);
                const checkCircular = (childId, potentialParentId) => {
                    if (!potentialParentId) return false;
                    let current = family.find(p => p.id === potentialParentId);
                    while (current) {
                        if (current.id === childId) return true;
                        // For a simple check, only go up one level. A full check is more complex.
                        if (current.parent1Id === childId || current.parent2Id === childId) return true; 
                        
                        // To avoid infinite loops in complex graphs, limit depth or use a visited set
                        if (current.parent1Id) current = family.find(p => p.id === current.parent1Id);
                        else if (current.parent2Id) current = family.find(p => p.id === current.parent2Id);
                        else current = null; // No more parents
                    }
                    return false;
                };

                if (checkCircular(selectedPersonId, parent1Id) || checkCircular(selectedPersonId, parent2Id)) {
                    alert("Circular parentage detected! Cannot set this parent.");
                    return;
                }
            }


            if (selectedPersonId) {
                // Update existing person
                const personToUpdate = family.find(p => p.id === selectedPersonId);
                if (personToUpdate) {
                    personToUpdate.name = name;
                    personToUpdate.birthYear = birthYear;
                    personToUpdate.deathYear = deathYear;
                    personToUpdate.parent1Id = parent1Id;
                    personToUpdate.parent2Id = parent2Id;
                    // personToUpdate.x is preserved if manually set, not reset to null here
                }
                showMessage('Person updated successfully!');
            } else {
                // Add new person
                const newPerson = {
                    id: generateId(),
                    name: name,
                    birthYear: birthYear,
                    deathYear: deathYear,
                    parent1Id: parent1Id,
                    parent2Id: parent2Id,
                    imageUrl: null, // New persons start without an image
                    x: null // Not manually positioned yet, will be auto-calculated
                };
                family.push(newPerson);
                showMessage('Person added successfully!');
            }

            updateParentSelect();
            drawFamilyTree();
            resetFormAndSelection();
        }

        function populateFormForEdit(person) {
            document.getElementById('personName').value = person.name;
            document.getElementById('birthYear').value = person.birthYear;
            document.getElementById('deathYear').value = person.deathYear || '';
            document.getElementById('imageUrlInput').value = person.imageUrl || ''; // Populate image URL input
            
            updateParentSelect(); // Re-populate to exclude self and select current parents
            document.getElementById('parent1Select').value = person.parent1Id || '';
            document.getElementById('parent2Select').value = person.parent2Id || '';

            document.getElementById('addUpdateBtn').textContent = 'Update Person';
        }

        function resetFormAndSelection() {
            document.getElementById('personName').value = '';
            document.getElementById('birthYear').value = '';
            document.getElementById('deathYear').value = '';
            document.getElementById('parent1Select').value = ''; // Clear parent 1 select
            document.getElementById('parent2Select').value = ''; // Clear parent 2 select
            document.getElementById('imageUrlInput').value = ''; // Clear image URL input
            document.getElementById('addUpdateBtn').textContent = 'Add Person';
            clearSelectionHighlight();
            selectedPersonId = null; 
            document.getElementById('loadImageBtn').disabled = true;
            document.getElementById('linkImageBtn').disabled = true; // Disable link image button
            document.getElementById('removePersonBtn').disabled = true; // Disable remove person button
            document.getElementById('removeImageBtn').disabled = true; // Disable remove image button on reset
        }

        function selectPerson(id) {
            // Remove 'selected' class from previously selected node
            clearSelectionHighlight();

            selectedPersonId = id;

            // Add 'selected' class to the newly selected node
            if (selectedPersonId) {
                const currentSelectedNode = document.querySelector(`.person-node[data-id="${selectedPersonId}"]`);
                if (currentSelectedNode) {
                    currentSelectedNode.classList.add('selected');
                }
                const person = family.find(p => p.id === selectedPersonId);
                if (person) {
                    populateFormForEdit(person);
                    document.getElementById('loadImageBtn').disabled = false;
                    document.getElementById('linkImageBtn').disabled = false; // Enable link image button
                    document.getElementById('removePersonBtn').disabled = false; // Enable remove person button
                    document.getElementById('removeImageBtn').disabled = !person.imageUrl; 
                }
            } else {
                // If selection cleared, reset form and buttons
                resetFormAndSelection();
            }
            updateParentSelect(); // Update dropdown based on current selection
        }

        function clearSelectionHighlight() {
            const prevSelectedNode = document.querySelector('.person-node.selected');
            if (prevSelectedNode) {
                prevSelectedNode.classList.remove('selected');
            }
        }

        function clearSelection() {
            selectPerson(null);
        }

        function handleImageUpload() {
            const fileInput = document.getElementById('imageFileInput');
            const file = fileInput.files[0];

            if (!file) return;
            if (!selectedPersonId) {
                alert('Please select a person first.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const personToUpdate = family.find(p => p.id === selectedPersonId);
                if (personToUpdate) {
                    personToUpdate.imageUrl = e.target.result;
                    document.getElementById('imageUrlInput').value = e.target.result; // Update URL input too
                    drawFamilyTree(); // Redraw with the new image
                    showMessage(`Image loaded for ${personToUpdate.name}.`);
                    document.getElementById('removeImageBtn').disabled = false; // Enable remove image button
                }
            };
            reader.readAsDataURL(file);
            fileInput.value = ''; // Clear file input
        }

        function linkImage() {
            const imageUrl = document.getElementById('imageUrlInput').value.trim();
            if (!imageUrl) {
                alert('Please enter an image URL.');
                return;
            }
            if (!selectedPersonId) {
                alert('Please select a person first.');
                return;
            }

            const personToUpdate = family.find(p => p.id === selectedPersonId);
            if (personToUpdate) {
                personToUpdate.imageUrl = imageUrl;
                drawFamilyTree();
                showMessage(`Image linked for ${personToUpdate.name}.`);
                document.getElementById('removeImageBtn').disabled = false; // Enable remove image button
            }
        }

        function removeImage() {
            if (!selectedPersonId) {
                alert('Please select a person first.');
                return;
            }

            const personToUpdate = family.find(p => p.id === selectedPersonId);
            if (personToUpdate) {
                personToUpdate.imageUrl = null;
                document.getElementById('imageUrlInput').value = '';
                drawFamilyTree();
                showMessage(`Image removed for ${personToUpdate.name}.`);
                document.getElementById('removeImageBtn').disabled = true; // Disable after removal
            }
        }

        // Background Image functions
        function handleBackgroundUpload() {
            const fileInput = document.getElementById('bgImageFileInput');
            const file = fileInput.files[0];

            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                backgroundImageUrl = e.target.result;
                updateBackgroundStyle(); // Apply the new image and current slider settings
                document.getElementById('removeBgImageBtn').disabled = false;
                showMessage('Background image loaded!');
            };
            reader.readAsDataURL(file);
            fileInput.value = ''; // Clear file input
        }

        function removeBackgroundImage() {
            backgroundImageUrl = null;
            updateBackgroundStyle(); // Apply the change
            document.getElementById('removeBgImageBtn').disabled = true;
            showMessage('Background image removed.');
        }

        function updateBackgroundStyle() {
            const treeContainer = document.querySelector('.tree-container');
            
            backgroundSize = parseInt(document.getElementById('bgSizeSlider').value);
            backgroundPosX = parseInt(document.getElementById('bgPosXSlider').value);
            backgroundPosY = parseInt(document.getElementById('bgPosYSlider').value);

            document.getElementById('currentBgSize').textContent = `${backgroundSize}%`;
            document.getElementById('currentBgPosX').textContent = `${backgroundPosX}%`;
            document.getElementById('currentBgPosY').textContent = `${backgroundPosY}%`;

            if (backgroundImageUrl) {
                treeContainer.style.backgroundImage = `url('${backgroundImageUrl}')`;
                treeContainer.style.backgroundRepeat = 'no-repeat';
                treeContainer.style.backgroundSize = `${backgroundSize}%`;
                treeContainer.style.backgroundPosition = `${backgroundPosX}% ${backgroundPosY}%`;
            } else {
                treeContainer.style.backgroundImage = 'none';
                treeContainer.style.backgroundSize = 'auto';
                treeContainer.style.backgroundPosition = '0 0';
            }
        }

        function showParentTooltip(event, personId) {
            const person = family.find(p => p.id === personId);
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('visible'); // Hide previous tooltip if any

            if (!person || (!person.parent1Id && !person.parent2Id)) {
                return; // No parents to show
            }

            let tooltipText = [];
            if (person.parent1Id) {
                const parent1 = family.find(p => p.id === person.parent1Id);
                if (parent1) tooltipText.push(`Parent 1: ${parent1.name} (${parent1.birthYear})`);
            }
            if (person.parent2Id) {
                const parent2 = family.find(p => p.id === person.parent2Id);
                if (parent2) tooltipText.push(`Parent 2: ${parent2.name} (${parent2.birthYear})`);
            }
            
            if (tooltipText.length > 0) {
                tooltip.innerHTML = tooltipText.join('<br>');
                
                const treeContainerRect = document.querySelector('.tree-container').getBoundingClientRect();
                const nodeRect = event.currentTarget.getBoundingClientRect(); // The SVG 'g' element
                
                // Position tooltip slightly above the node, centered horizontally
                tooltip.style.left = `${nodeRect.left - treeContainerRect.left + nodeRect.width / 2}px`;
                tooltip.style.top = `${nodeRect.top - treeContainerRect.top - tooltip.offsetHeight - 10}px`;
                
                tooltip.classList.add('visible');
            }
        }

        function hideParentTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('visible');
        }

        function updateZoom() {
            pixelsPerYear = parseFloat(document.getElementById('zoomSlider').value);
            document.getElementById('currentZoom').textContent = `${pixelsPerYear.toFixed(1)}x`;
            // Recalculate TOP_PADDING based on current imageSize and redraw
            TOP_PADDING = imageSize + 10;
            drawFamilyTree();
        }

        function updateImageSize() {
            imageSize = parseInt(document.getElementById('imageSizeInput').value);
            document.getElementById('currentImageSize').textContent = `${imageSize}px`;
            // Recalculate TOP_PADDING based on current imageSize and redraw
            TOP_PADDING = imageSize + 10;
            drawFamilyTree();
        }
        
        function toggleLifelines() {
            showLifelines = !showLifelines;
            drawFamilyTree();
            showMessage(`Lifelines ${showLifelines ? 'shown' : 'hidden'}.`);
        }

        function toggleYearLines() {
            showYearLines = !showYearLines;
            drawFamilyTree();
            showMessage(`Year lines ${showYearLines ? 'shown' : 'hidden'}.`);
        }

        // Function to update overall tree scale
        function updateTreeScale() {
            treeScale = parseFloat(document.getElementById('treeScaleSlider').value);
            document.getElementById('currentTreeScale').textContent = `${treeScale.toFixed(1)}x`;
            const svg = document.getElementById('familyTreeSvg');
            // Apply both rotation and scale as CSS transform
            svg.style.transform = `scale(${treeScale}) rotate(${rotationAngle}deg)`;
        }

        function rotateTree() {
            rotationAngle = (rotationAngle + 90) % 360;
            const svg = document.getElementById('familyTreeSvg');
            // Apply both rotation and scale as CSS transform
            svg.style.transform = `scale(${treeScale}) rotate(${rotationAngle}deg)`;
            showMessage(`Tree rotated to ${rotationAngle} degrees.`);
            drawFamilyTree(); // Redraw to apply inverse rotation to text elements, images, AND boxes
        }

        function removePerson() {
            if (!selectedPersonId) {
                alert('Please select a person to remove.');
                return;
            }

            const personToRemove = family.find(p => p.id === selectedPersonId);
            if (!personToRemove) {
                alert('Selected person not found.');
                return;
            }

            if (!confirm(`Are you sure you want to remove ${personToRemove.name}? This cannot be undone.`)) {
                return;
            }

            // Remove the person from the family array
            family = family.filter(p => p.id !== selectedPersonId);

            // Update parentIds of children of the removed person
            family.forEach(p => {
                if (p.parent1Id === personToRemove.id) {
                    p.parent1Id = null; 
                }
                if (p.parent2Id === personToRemove.id) {
                    p.parent2Id = null;
                }
            });

            showMessage(`${personToRemove.name} removed.`);
            drawFamilyTree();
            resetFormAndSelection(); // Clear selection and form
        }

        // --- Drag and Drop Functions ---
        const svgElement = document.getElementById('familyTreeSvg');
        svgElement.addEventListener('mousedown', startDrag);
        svgElement.addEventListener('mousemove', drag);
        svgElement.addEventListener('mouseup', endDrag);
        svgElement.addEventListener('mouseleave', endDrag); // End drag if mouse leaves SVG

        function getMouseSvgCoordinates(event) {
            const ctm = svgElement.getScreenCTM();
            // Invert the CTM to transform screen coordinates to SVG user coordinates
            if (ctm) {
                const inverseCTM = ctm.inverse();
                // Apply the inverse matrix to the clientX/Y
                const svgPoint = svgElement.createSVGPoint();
                svgPoint.x = event.clientX;
                svgPoint.y = event.clientY;
                const transformedPoint = svgPoint.matrixTransform(inverseCTM);
                return {
                    x: transformedPoint.x,
                    y: transformedPoint.y
                };
            }
            // Fallback if CTM is not available or inverse fails
            return { x: event.clientX, y: event.clientY };
        }


        function startDrag(event) {
            // Only drag on the person node (g element), not the background
            const targetNode = event.target.closest('.person-node');
            if (targetNode) {
                isDragging = true;
                draggedPersonId = targetNode.dataset.id;
                draggedSvgGroup = targetNode;
                targetNode.classList.add('dragging');

                const person = family.find(p => p.id === draggedPersonId);
                if (person) {
                    const mouseCoords = getMouseSvgCoordinates(event);
                    initialMouseX = mouseCoords.x;
                    
                    // Get the current translation X from the SVG group's transform attribute
                    const transform = draggedSvgGroup.getAttribute('transform');
                    const match = transform.match(/translate\(([^,]+)/);
                    let currentRenderedX = person.x; // Fallback to data model if parse fails
                    if (match && match[1]) {
                        currentRenderedX = parseFloat(match[1]);
                    }
                    
                    // Calculate the offset from the node's current rendered X position to the mouse X position
                    dragOffsetX = initialMouseX - currentRenderedX;
                }
            }
        }

        function drag(event) {
            if (!isDragging || !draggedPersonId) return;
            event.preventDefault(); // Prevent text selection etc.

            const mouseCoords = getMouseSvgCoordinates(event);
            // New person X is current mouse X minus the initial offset
            const newX = mouseCoords.x - dragOffsetX; 

            const person = family.find(p => p.id === draggedPersonId);
            if (person) {
                person.x = newX;
                drawFamilyTree(); // Redraw to update the lines dynamically
                // Re-apply dragging and selected class after redraw, as SVG elements are replaced
                const reDraggedNode = document.querySelector(`.person-node[data-id="${draggedPersonId}"]`);
                if (reDraggedNode) {
                    reDraggedNode.classList.add('dragging');
                    if (selectedPersonId === draggedPersonId) {
                        reDraggedNode.classList.add('selected');
                    }
                }
            }
        }

        function endDrag() {
            if (isDragging) {
                if (draggedSvgGroup) {
                    draggedSvgGroup.classList.remove('dragging');
                }
                isDragging = false;
                draggedPersonId = null;
                draggedSvgGroup = null;
            }
        }
        // --- End Drag and Drop Functions ---

        // Helper function to wrap text within a given width
        function getWrappedText(text, maxWidth, fontSize) {
            const svg = document.getElementById('familyTreeSvg');
            const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tempText.style.fontSize = `${fontSize}px`;
            tempText.style.fontFamily = 'Arial, sans-serif'; // Ensure consistent font for measurement
            svg.appendChild(tempText); 

            const words = text.split(' ');
            let line = '';
            let lines = [];
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + (i > 0 ? ' ' : '') + words[i];
                tempText.textContent = testLine;
                if (tempText.getComputedTextLength() > maxWidth && i > 0) {
                    lines.push(line);
                    line = words[i];
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            
            svg.removeChild(tempText); // Remove the temporary text element

            const maxApproxCharsPerLine = Math.floor(maxWidth / (fontSize * 0.6)); // Rough estimate
            return lines.map(l => {
                if (l.length > maxApproxCharsPerLine + 5 && l.includes(' ')) { 
                    const parts = l.split(' ');
                    let currentTruncated = '';
                    for (const part of parts) {
                        if ((currentTruncated + ' ' + part).length <= maxApproxCharsPerLine - 3) {
                            currentTruncated += (currentTruncated ? ' ' : '') + part;
                        } else {
                            break;
                        }
                    }
                    if (currentTruncated !== l && currentTruncated.length > 0) {
                        return currentTruncated + '...';
                    }
                } else if (l.length > maxApproxCharsPerLine * 1.5) { 
                     return l.substring(0, maxApproxCharsPerLine * 1.5 - 3) + '...';
                }
                return l;
            });
        }


        function drawFamilyTree() {
            const svg = document.getElementById('familyTreeSvg');
            svg.innerHTML = ''; // Clear existing SVG content

            if (family.length === 0) {
                return;
            }

            // Calculate min/max years for vertical scaling and year lines
            let minYear = Math.min(...family.map(p => p.birthYear));
            let maxYear = Math.max(...family.map(p => p.deathYear || new Date().getFullYear()));
            minYear = Math.floor(minYear / YEAR_LINE_INTERVAL) * YEAR_LINE_INTERVAL; // Round down to nearest interval
            maxYear = Math.ceil(maxYear / YEAR_LINE_INTERVAL) * YEAR_LINE_INTERVAL;   // Round up to nearest interval

            const svgContainerWidth = svg.parentElement.offsetWidth - 40; // Parent width minus padding
            
            // Create a map for easy lookup and to hold layout properties
            const peopleMap = new Map(family.map(p => [p.id, { ...p, children: [], y: 0, level: 0, actualNodeHeight: MIN_NODE_HEIGHT }]));

            // Build child references (a person can have two parents)
            family.forEach(person => {
                if (person.parent1Id && peopleMap.has(person.parent1Id)) {
                    peopleMap.get(person.parent1Id).children.push(peopleMap.get(person.id));
                }
                if (person.parent2Id && peopleMap.has(person.parent2Id)) {
                    // Avoid adding the same child twice if both parents are in the map
                    const parent1Children = peopleMap.get(person.parent1Id)?.children || [];
                    if (!peopleMap.get(person.parent1Id) || parent1Children.indexOf(peopleMap.get(person.id)) === -1) {
                         peopleMap.get(person.parent2Id).children.push(peopleMap.get(person.id));
                    }
                }
            });

            // Find root nodes (no parents in the current family)
            const rootNodes = Array.from(peopleMap.values()).filter(p => !p.parent1Id && !p.parent2Id);
            rootNodes.sort((a, b) => a.birthYear - b.birthYear); // Sort by birth year to keep older ones higher


            // Layout algorithm:
            // 1. Assign levels (generations)
            function assignLevel(person, level) {
                person.level = level;
                person.children.forEach(child => assignLevel(child, level + 1));
            }
            rootNodes.forEach(node => assignLevel(node, 0));

            // Calculate node heights based on text wrapping
            peopleMap.forEach(person => {
                const nameFontSize = 12;
                const yearsFontSize = 12;
                const nameLineHeight = nameFontSize * 1.2;
                const yearsLineHeight = yearsFontSize * 1.2;

                const wrappedNameLines = getWrappedText(person.name, NODE_WIDTH - 20, nameFontSize); // 20px for horizontal padding

                let textContentHeight = (wrappedNameLines.length * nameLineHeight) + yearsLineHeight + 5; // +5 for minor gap
                
                let calculatedHeight = textContentHeight;
                if (person.imageUrl) {
                    calculatedHeight += imageSize + 10; // Image height + top/bottom padding for image
                } else {
                    calculatedHeight += 10; // General top/bottom padding if no image
                }

                person.actualNodeHeight = Math.max(MIN_NODE_HEIGHT, calculatedHeight);
            });


            // 2. Assign Y positions (top of the node aligns with birth year)
            // 3. Assign X positions, respecting manually set `person.x` or calculating if `null`.
            const xPositionsByLevel = {}; // Tracks the next available X position for each level if auto-calculating

            function assignXPositions(person) {
                // Y position: top of the node aligns with birth year
                person.y = (person.birthYear - minYear) * pixelsPerYear + TOP_PADDING;

                if (person.x !== null) {
                    // If person.x is already set (e.g., by dragging or import), use it.
                    // Recursively position children based on their own rules
                    person.children.sort((a, b) => a.birthYear - b.birthYear);
                    person.children.forEach(child => assignXPositions(child));
                } else {
                    // Auto-calculate X position if not manually set
                    if (person.children.length === 0) {
                        // Leaf node: place at the next available X for its level
                        if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50; // Initial margin
                        
                        person.x = xPositionsByLevel[person.level];
                        xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                    } else if (person.parent1Id && person.parent2Id) {
                        // Try to center between two parents if both are known and laid out
                        const p1 = peopleMap.get(person.parent1Id);
                        const p2 = peopleMap.get(person.parent2Id);

                        if (p1 && p1.x !== null && p2 && p2.x !== null) {
                            person.x = (p1.x + p2.x) / 2 - NODE_WIDTH / 2;
                        } else if (p1 && p1.x !== null) {
                            person.x = p1.x; // Fallback to parent1's x if parent2 unknown
                        } else if (p2 && p2.x !== null) {
                            person.x = p2.x; // Fallback to parent2's x if parent1 unknown
                        } else {
                            // If parents not yet laid out or not found, place sequentially
                            if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                        }
                    }
                    else if (person.parent1Id) {
                         // Place relative to single parent
                         const p1 = peopleMap.get(person.parent1Id);
                         if (p1 && p1.x !== null) {
                            person.x = p1.x; // Start under parent
                         } else {
                            if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                         }
                    } else if (person.parent2Id) { // Fallback for only parent2 set
                         const p2 = peopleMap.get(person.parent2Id);
                         if (p2 && p2.x !== null) {
                            person.x = p2.x; // Start under parent
                         } else {
                            if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                         }
                    } else { // Truly a root node
                        if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                        person.x = xPositionsByLevel[person.level];
                        xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                    }

                    // Ensure horizontal spacing for auto-placed nodes at the same level
                    if (person.x !== null) {
                        if (!xPositionsByLevel[person.level] || person.x > xPositionsByLevel[person.level]) {
                            xPositionsByLevel[person.level] = person.x + NODE_WIDTH + HORIZONTAL_SPACING;
                        } else {
                            // Adjust x if it overlaps with a previous node on the same level that was auto-placed
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                        }
                    }

                    // Recursively position children if this person's X was just determined
                    person.children.sort((a, b) => a.birthYear - b.birthYear);
                    person.children.forEach(child => assignXPositions(child));
                }
            }
            
            // Execute the layout for all nodes
            rootNodes.forEach(node => assignXPositions(node));


            // Determine overall SVG width and height needed based on calculated positions and actualNodeHeight
            let maxCalculatedX = 0;
            let maxCalculatedY = 0;
            Array.from(peopleMap.values()).forEach(p => {
                maxCalculatedX = Math.max(maxCalculatedX, p.x + NODE_WIDTH);
                maxCalculatedY = Math.max(maxCalculatedY, p.y + p.actualNodeHeight); // Use actualNodeHeight
            });

            const finalSvgWidth = Math.max(svgContainerWidth, maxCalculatedX + 50); // Ensure enough space
            const finalSvgHeight = maxCalculatedY + 50; // Add padding for bottom
            
            svg.setAttribute('viewBox', `0 0 ${finalSvgWidth} ${finalSvgHeight}`);
            svg.setAttribute('height', finalSvgHeight);
            // Apply overall SVG rotation and scale
            svg.style.transform = `scale(${treeScale}) rotate(${rotationAngle}deg)`;

            // Drawing year lines first (conditional)
            if (showYearLines) {
                for (let year = minYear; year <= maxYear; year += YEAR_LINE_INTERVAL) {
                    const yPos = (year - minYear) * pixelsPerYear + TOP_PADDING;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', yPos);
                    line.setAttribute('x2', finalSvgWidth);
                    line.setAttribute('y2', yPos);
                    line.setAttribute('class', 'year-line');
                    svg.appendChild(line);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const textX = finalSvgWidth - 10;
                    const textY = yPos - 5;
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('class', 'year-label');
                    text.textContent = year;
                    // Apply inverse rotation around its own position
                    text.setAttribute('transform', `rotate(${-rotationAngle} ${textX} ${textY})`);
                    svg.appendChild(text);
                }
            }

            // Draw connections (lines) first, then nodes
            peopleMap.forEach(person => {
                // Draw line for Parent 1
                if (person.parent1Id && peopleMap.has(person.parent1Id)) {
                    const parent = peopleMap.get(person.parent1Id);
                    const parentCenterX = parent.x + NODE_WIDTH / 2;
                    const parentBottomY = parent.y + parent.actualNodeHeight;
                    const childCenterX = person.x + NODE_WIDTH / 2;
                    const childTopY = person.y;

                    const midY = parentBottomY + (childTopY - parentBottomY) / 2;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let path = `M ${parentCenterX} ${parentBottomY}
                                V ${midY}
                                H ${childCenterX}
                                V ${childTopY}`;
                    line.setAttribute('d', path);
                    line.setAttribute('class', 'person-line');
                    svg.appendChild(line);
                }

                // Draw line for Parent 2
                if (person.parent2Id && peopleMap.has(person.parent2Id)) {
                    const parent = peopleMap.get(person.parent2Id);
                    const parentCenterX = parent.x + NODE_WIDTH / 2;
                    const parentBottomY = parent.y + parent.actualNodeHeight;
                    const childCenterX = person.x + NODE_WIDTH / 2;
                    const childTopY = person.y;

                    const midY = parentBottomY + (childTopY - parentBottomY) / 2;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let path = `M ${parentCenterX} ${parentBottomY}
                                V ${midY}
                                H ${childCenterX}
                                V ${childTopY}`;
                    line.setAttribute('d', path);
                    line.setAttribute('class', 'person-line');
                    svg.appendChild(line);
                }
            });

            // Draw nodes
            peopleMap.forEach(person => {
                const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                nodeGroup.setAttribute('class', `person-node ${selectedPersonId === person.id ? 'selected' : ''}`);
                nodeGroup.setAttribute('data-id', person.id);
                // Translate to the top-left corner of the node
                nodeGroup.setAttribute('transform', `translate(${person.x}, ${person.y})`);
                nodeGroup.onclick = (e) => { e.stopPropagation(); selectPerson(person.id); }; // Select on click
                nodeGroup.onmouseover = (e) => showParentTooltip(e, person.id);
                nodeGroup.onmouseout = hideParentTooltip;

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', 0);
                rect.setAttribute('y', 0);
                rect.setAttribute('width', NODE_WIDTH);
                rect.setAttribute('height', person.actualNodeHeight); 
                // Calculate center of rect relative to nodeGroup's origin for rotation
                const rectCenterX = NODE_WIDTH / 2;
                const rectCenterY = person.actualNodeHeight / 2;
                rect.setAttribute('transform', `rotate(${-rotationAngle} ${rectCenterX} ${rectCenterY})`);
                nodeGroup.appendChild(rect);

                let contentY = 0; // Tracks the current vertical position within the node for placing elements

                if (person.imageUrl) {
                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', person.imageUrl);
                    const imageX = (NODE_WIDTH - imageSize) / 2; // Center horizontally
                    const imageY = 5; // A bit of padding at the top
                    image.setAttribute('x', imageX); 
                    image.setAttribute('y', imageY); 
                    image.setAttribute('width', imageSize);
                    image.setAttribute('height', imageSize);
                    image.setAttribute('class', 'node-image');
                    // Calculate center of image relative to nodeGroup's origin for rotation
                    const imageCenterX = imageX + imageSize / 2;
                    const imageCenterY = imageY + imageSize / 2;
                    image.setAttribute('transform', `rotate(${-rotationAngle} ${imageCenterX} ${imageCenterY})`);
                    nodeGroup.appendChild(image);
                    contentY = imageY + imageSize + 5; // Update contentY to be below the image + a little padding
                }

                const nameFontSize = 12;
                const yearsFontSize = 12;
                const nameLineHeight = nameFontSize * 1.2;
                const yearsLineHeight = yearsFontSize * 1.2;

                const wrappedNameLines = getWrappedText(person.name, NODE_WIDTH - 20, nameFontSize); // 20px for horizontal padding

                const totalTextHeight = (wrappedNameLines.length * nameLineHeight) + yearsLineHeight;

                // Calculate the starting Y for the text block to center it vertically within the remaining space
                let textBlockStartY = contentY + (person.actualNodeHeight - contentY - totalTextHeight) / 2;
                if (textBlockStartY < contentY) textBlockStartY = contentY; // Ensure it doesn't go too high

                wrappedNameLines.forEach((lineText, index) => {
                    const nameText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const nameTextX = NODE_WIDTH / 2; // Center horizontally
                    const nameTextY = textBlockStartY + (index * nameLineHeight) + (nameLineHeight / 2); // Vertically center each line
                    nameText.setAttribute('x', nameTextX); 
                    nameText.setAttribute('y', nameTextY); 
                    nameText.textContent = lineText;
                    nameText.setAttribute('class', 'name-text'); 
                    // Calculate center of text line relative to nodeGroup's origin for rotation
                    nameText.setAttribute('transform', `rotate(${-rotationAngle} ${nameTextX} ${nameTextY})`);
                    nodeGroup.appendChild(nameText);
                });

                const yearsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const yearsTextX = NODE_WIDTH / 2; // Center horizontally
                const yearsTextY = textBlockStartY + (wrappedNameLines.length * nameLineHeight) + (yearsLineHeight / 2); // Position after wrapped names
                yearsText.setAttribute('x', yearsTextX); 
                yearsText.setAttribute('y', yearsTextY); 
                yearsText.textContent = `${person.birthYear} - ${person.deathYear || 'Present'}`;
                // Calculate center of text line relative to nodeGroup's origin for rotation
                yearsText.setAttribute('transform', `rotate(${-rotationAngle} ${yearsTextX} ${yearsTextY})`);
                nodeGroup.appendChild(yearsText);

                svg.appendChild(nodeGroup);

                // Draw lifeline if enabled
                if (showLifelines) {
                    const lifeline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    const lifelineX = person.x + NODE_WIDTH + LIFELINE_OFFSET;
                    
                    const currentOrDeathYear = person.deathYear || new Date().getFullYear();
                    const lifelineY1 = (person.birthYear - minYear) * pixelsPerYear + TOP_PADDING;
                    const lifelineY2 = (currentOrDeathYear - minYear) * pixelsPerYear + TOP_PADDING;

                    lifeline.setAttribute('x1', lifelineX);
                    lifeline.setAttribute('y1', lifelineY1);
                    lifeline.setAttribute('x2', lifelineX);
                    lifeline.setAttribute('y2', lifelineY2);
                    lifeline.setAttribute('class', 'lifeline');
                    svg.appendChild(lifeline);
                }
            });

            // Click on SVG background to clear selection
            svg.onclick = clearSelection;
        }

        // Helper to parse CSV content into family array
        function parseCsvContent(content) {
            const lines = content.split('\n').filter(line => line.trim() !== '');

            if (lines.length < 2) {
                console.warn('CSV file is empty or malformed.');
                return { family: [], maxIdNum: 0 };
            }

            const parseCsvLine = (line) => {
                const values = [];
                let inQuote = false;
                let currentVal = '';
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        if (i + 1 < line.length && line[i + 1] === '"') { // Escaped double quote
                            currentVal += '"';
                            i++; // Skip the next quote
                        } else {
                            inQuote = !inQuote;
                        }
                    } else if (char === ',' && !inQuote) {
                        values.push(currentVal);
                        currentVal = '';
                    } else {
                        currentVal += char;
                    }
                }
                values.push(currentVal); // Add the last value
                return values.map(v => v.trim()); // Trim whitespace
            };

            const headers = parseCsvLine(lines[0]);
            if (!headers.includes('ID') || !headers.includes('Name') || !headers.includes('BirthYear')) {
                console.error('CSV must contain "ID", "Name", and "BirthYear" columns.');
                return { family: [], maxIdNum: 0 };
            }

            const newFamily = [];
            let maxIdNum = 0;

            for (let i = 1; i < lines.length; i++) {
                const values = parseCsvLine(lines[i]);
                if (values.length !== headers.length) {
                     console.warn(`Skipping malformed row (column count mismatch): ${lines[i]}`);
                     continue;
                }

                const person = {};
                headers.forEach((header, index) => {
                    const value = values[index];
                    if (header === 'ID') {
                        person.id = value;
                        const num = parseInt(value.substring(1));
                        if (!isNaN(num)) maxIdNum = Math.max(maxIdNum, num);
                    } else if (header === 'Name') {
                        person.name = value;
                    } else if (header === 'BirthYear') {
                        person.birthYear = parseInt(value);
                        if (isNaN(person.birthYear)) person.birthYear = null;
                    } else if (header === 'DeathYear') {
                        person.deathYear = value ? parseInt(value) : null;
                    } else if (header === 'Parent1ID') {
                        person.parent1Id = value || null;
                    } else if (header === 'Parent2ID') {
                        person.parent2Id = value || null;
                    } else if (header === 'ImageURL') {
                        person.imageUrl = value || null;
                    } else if (header === 'XPosition') {
                        person.x = value ? parseFloat(value) : null;
                    }
                });

                if (person.id && person.name && person.birthYear !== null && !isNaN(person.birthYear)) {
                    newFamily.push(person);
                } else {
                    console.warn('Skipping incomplete or invalid person data from CSV:', person);
                }
            }
            return { family: newFamily, maxIdNum: maxIdNum };
        }

        async function loadFamilyFromURL(url) {
            if (!url) {
                console.log("No example family selected.");
                clearTree(); // Clear existing tree if no selection
                return;
            }
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvContent = await response.text();
                
                const parsedData = parseCsvContent(csvContent);
                if (parsedData.family.length > 0) {
                    family = parsedData.family;
                    nextPersonId = parsedData.maxIdNum + 1;
                    updateParentSelect();
                    drawFamilyTree();
                    resetFormAndSelection();
                    showMessage(`'${url.split('/').pop().replace('_family.csv', '').replace(/_/g, ' ')}' family loaded successfully!`);
                } else {
                    alert(`Failed to load or parse data from ${url}.`);
                    clearTree();
                }
            } catch (error) {
                console.error('Error loading family data:', error);
                alert(`Could not load family data from ${url}. Make sure the file exists and is accessible.`);
                clearTree();
            }
        }

        function loadFamilyFromSelectedExample() {
            const selectElement = document.getElementById('exampleFamilySelect');
            const filename = selectElement.value; // e.g., "cleopatra_family.csv"
            
            if (filename) {
                loadFamilyFromURL(filename);
            } else {
                clearTree(); // If "Load Example Family" (empty value) is selected
            }
            // Reset dropdown to default "Load Example Family" after selection
            // This allows re-selecting the same family or choosing another.
            selectElement.value = ""; 
        }

        function importFromCsv() {
            const fileInput = document.getElementById('importCsvFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a CSV file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const parsedData = parseCsvContent(content); 
                
                if (parsedData.family.length > 0) {
                    family = parsedData.family;
                    nextPersonId = parsedData.maxIdNum + 1;
                    updateParentSelect();
                    drawFamilyTree();
                    resetFormAndSelection();
                    showMessage('Family tree imported successfully!');
                } else {
                    alert('Failed to import family tree from CSV.');
                }
            };

            reader.readAsText(file);
            fileInput.value = ''; // Clear the file input
        }

        // --- New Function: Export to CSV ---
        function exportToCsv() {
            if (family.length === 0) {
                alert('No family data to export.');
                return;
            }

            const headers = ["ID", "Name", "BirthYear", "DeathYear", "Parent1ID", "Parent2ID", "ImageURL", "XPosition"];
            // Quote headers to handle potential commas in header names (though not strictly needed here)
            let csvContent = headers.map(header => `"${header}"`).join(',') + '\n';

            family.forEach(person => {
                const row = headers.map(header => {
                    let value;
                    switch (header) {
                        case "ID":
                            value = person.id;
                            break;
                        case "Name":
                            value = person.name;
                            break;
                        case "BirthYear":
                            value = person.birthYear;
                            break;
                        case "DeathYear":
                            value = person.deathYear;
                            break;
                        case "Parent1ID":
                            value = person.parent1Id;
                            break;
                        case "Parent2ID":
                            value = person.parent2Id;
                            break;
                        case "ImageURL":
                            value = person.imageUrl;
                            break;
                        case "XPosition":
                            value = person.x;
                            break;
                        default:
                            value = ''; // Should not happen with defined headers
                    }

                    // Convert null/undefined to empty string for CSV, and ensure it's a string for processing
                    let stringValue = (value === null || typeof value === 'undefined') ? '' : String(value);

                    // Escape double quotes by replacing them with two double quotes, and wrap in quotes if value contains comma or double quote
                    if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) { // Added newline check for robustness
                        return `"${stringValue.replace(/"/g, '""')}"`;
                    }
                    return stringValue;
                }).join(',');
                csvContent += row + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection for download attribute
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'family_tree.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showMessage('Family tree exported to CSV!');
            } else {
                alert('Your browser does not support downloading files directly. Please copy the text below:\n\n' + csvContent);
            }
        }
        // --- End New Function: Export to CSV ---


        function saveAsJpg() {
            const treeContainer = document.querySelector('.tree-container'); 

            if (!treeContainer || family.length === 0) {
                alert("No tree to save or SVG element not found.");
                return;
            }

            // Temporarily remove the selection highlight for a cleaner image
            const selectedNode = document.querySelector('.person-node.selected');
            if (selectedNode) selectedNode.classList.remove('selected');

            domtoimage.toJpeg(treeContainer, { quality: 0.95, bgcolor: '#2b2b2b' }) 
                .then(function (dataUrl) {
                    const link = document.createElement('a');
                    link.download = 'family_tree.jpg';
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showMessage('Family tree saved as JPG!');
                })
                .catch(function (error) {
                    console.error('Oops, something went wrong while saving as JPG!', error);
                    alert('Failed to save as JPG. Check console for details. (Images in SVG might cause issues)');
                })
                .finally(() => {
                    // Re-apply selection highlight if it was removed
                    if (selectedNode) selectedNode.classList.add('selected');
                });
        }


        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            // Set slider values and update displays
            document.getElementById('zoomSlider').value = pixelsPerYear;
            document.getElementById('currentZoom').textContent = `${pixelsPerYear.toFixed(1)}x`;
            
            document.getElementById('imageSizeInput').value = imageSize;
            document.getElementById('currentImageSize').textContent = `${imageSize}px`;

            // Initialize background image sliders and style
            document.getElementById('bgSizeSlider').value = backgroundSize;
            document.getElementById('currentBgSize').textContent = `${backgroundSize}%`;
            document.getElementById('bgPosXSlider').value = backgroundPosX;
            document.getElementById('currentBgPosX').textContent = `${backgroundPosX}%`;
            document.getElementById('bgPosYSlider').value = backgroundPosY;
            document.getElementById('currentBgPosY').textContent = `${bgPosY}%`;
            updateBackgroundStyle(); // Apply initial background settings

            // Initialize tree scale slider
            document.getElementById('treeScaleSlider').value = treeScale;
            document.getElementById('currentTreeScale').textContent = `${treeScale.toFixed(1)}x`;
            updateTreeScale(); // Apply initial tree scale

            // Update TOP_PADDING initially
            TOP_PADDING = imageSize + 10; 

            resetFormAndSelection(); // Ensure buttons are initially disabled and form is reset
            drawFamilyTree(); // Draw an empty tree initially or load a default if desired.
        });
    </script>
</body>
</html>
