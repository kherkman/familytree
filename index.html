<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Tree Maker</title>
    <!-- dom-to-image for Save to JPG functionality -->
    <script src="https://cdn.jsdelivr.net/npm/dom-to-image@2.6.0/dist/dom-to-image.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a; /* Dark background */
            color: #f0f0f0; /* Light text */
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #ffa500; /* Orange for title */
        }

        .controls {
            background-color: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 800px;
            display: flex;
            flex-direction: column; /* Changed to column to stack sections */
            gap: 20px; /* Space between sections */
        }

        .control-section { /* NEW: Styling for individual control sections */
            background-color: #444;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            /* Changed to column to properly manage content visibility */
            flex-direction: column; 
            align-items: flex-start; /* Align items to start for h3 and content */
        }

        .control-section h3 { /* NEW: Section headings */
            color: #ffa500;
            width: 100%;
            text-align: left; /* Align text to left */
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
            cursor: pointer; /* Indicate it's clickable */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toggle-icon {
            font-size: 0.8em;
            margin-left: 10px;
            transition: transform 0.2s ease;
        }

        .control-section.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .control-section-content {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            width: 100%; /* Ensure content takes full width */
            overflow: hidden;
            max-height: 500px; /* Arbitrary max-height for transition */
            opacity: 1;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            pointer-events: auto; /* Allow interactions */
        }

        .control-section.collapsed .control-section-content {
            max-height: 0;
            opacity: 0;
            pointer-events: none; /* Disable interactions when collapsed */
        }

        .controls input[type="text"],
        .controls input[type="number"],
        .controls select {
            padding: 10px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #444;
            color: #f0f0f0;
            font-size: 1em;
            width: 180px; /* Adjust width as needed */
        }

        .controls input[type="range"] {
            -webkit-appearance: none;
            width: 150px;
            height: 8px;
            background: #555;
            outline: none;
            border-radius: 4px;
        }

        .controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffa500;
            cursor: grab;
            border: 2px solid #333;
        }

        .controls input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffa500;
            cursor: grab;
            border: 2px solid #333;
        }

        .controls input[type="text"]::placeholder,
        .controls input[type="number"]::placeholder {
            color: #bbb;
        }

        .controls button {
            background-color: #ffa500; /* Orange button */
            color: #1a1a1a;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .controls button:hover:not(:disabled) {
            background-color: #e69500;
        }
        
        .controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
            color: #bbb;
        }

        /* Color picker styling */
        .controls input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            width: 40px; /* Smaller width for color picker */
            height: 28px; /* Adjusted height */
            padding: 0;
            border-radius: 4px;
            background-color: transparent;
            cursor: pointer;
            vertical-align: middle; /* Align with text */
        }

        .controls input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .controls input[type="color"]::-webkit-color-swatch {
            border: 1px solid #555;
            border-radius: 3px;
        }

        .controls input[type="color"]::-moz-color-swatch-wrapper {
            padding: 0;
        }

        .controls input[type="color"]::-moz-color-swatch {
            border: 1px solid #555;
            border-radius: 3px;
        }

        .tree-container {
            background-color: #2b2b2b; /* Default background, will be overridden by JS */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 20px;
            overflow: auto; /* Enable scrolling if content overflows */
            width: 90%;
            max-width: 1000px;
            min-height: 500px; /* Ensure some visibility */
            position: relative; /* For tooltip positioning */
            background-repeat: no-repeat;
            background-size: 100%;
            background-position: 0% 0%;
        }

        svg {
            width: 100%;
            height: auto;
            min-height: 500px;
            display: block;
            user-select: none; /* Prevent text selection during drag */
            transition: transform 0.3s ease-in-out; /* Smooth rotation and scaling */
            transform-origin: center center; /* Rotate and scale around its center */
        }

        .person-node rect, .person-node circle {
            fill: #444; /* Default box color, will be overridden by JS */
            stroke: #ffa500; /* Default box line color, will be overridden by JS */
            stroke-width: 2;
            rx: 5;
            ry: 5;
            transition: stroke-width 0.2s ease, stroke 0.2s ease;
            cursor: grab; /* Indicate draggable */
        }

        .person-node.dragging rect, .person-node.dragging circle {
            cursor: grabbing;
        }

        .person-node.selected rect, .person-node.selected circle {
            stroke: #00bfff; /* Highlight selected node with blue */
            stroke-width: 3;
        }

        .person-node text {
            fill: #f0f0f0; /* Default text color, will be overridden by JS */
            font-size: 12px; /* Default font size, will be overridden by JS */
            text-anchor: middle; /* NEW: Centered text */
            pointer-events: none; /* Allow click/drag to pass to the group */
        }
        
        .person-node .name-text {
            dominant-baseline: central; /* Align text vertically in the middle of its line */
        }


        .person-node .node-image {
            object-fit: cover; /* Cover the area */
            stroke: none; /* No stroke on image itself, as clipPath will define border */
            border-radius: 50%; /* Make images round (if not clipped, this would apply) */
            pointer-events: none; /* Allow click/drag to pass to the group */
        }

        .person-line {
            stroke: #ffa500; /* Default line color, will be overridden by JS */
            stroke-width: 2; /* Default line thickness, will be overridden by JS */
            fill: none;
        }

        .lifeline {
            stroke: #8a2be2; /* Purple color for lifeline */
            stroke-width: 2;
            fill: none;
        }

        .year-line {
            stroke: #777;
            stroke-width: 1;
            stroke-dasharray: 4 2;
        }

        .year-label {
            fill: #f0f0f0; /* Default year label color, will be overridden by JS */
            font-size: 12px; /* Default year label size, will be overridden by JS */
            text-anchor: end;
        }

        .hidden-file-input {
            display: none;
        }

        .tooltip {
            position: absolute;
            background-color: #333;
            color: #f0f0f0; /* Default tooltip text color, will be overridden by JS */
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none; /* Allows clicks to pass through to elements below */
            opacity: 0;
            transition: opacity 0.2s ease;
            white-space: nowrap;
            z-index: 10;
            border: 1px solid #ffa500; /* Default border color, will be overridden by JS */
            font-size: 13px; /* Default tooltip font size, will be overridden by JS */
            transform: translateX(-50%); /* Center horizontally */
        }

        .tooltip.visible {
            opacity: 1;
        }

        .zoom-label {
            color: #f0f0f0;
            font-size: 0.9em;
            margin-left: 10px;
            min-width: 30px; /* Ensure space for current zoom value */
            text-align: right;
        }

        /* Message Box Styling */
        #messageBox {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.1); /* Slightly transparent white */
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 100;
            pointer-events: none; /* Ensure it doesn't block interactions */
        }

        #messageBox.visible {
            opacity: 1;
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 101; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            padding-top: 60px;
        }

        .modal-content {
            background-color: #333;
            margin: 5% auto; /* 5% from the top and centered */
            padding: 30px;
            border: 1px solid #555;
            border-radius: 8px;
            width: 90%; /* Could be more or less, depending on screen size */
            max-width: 1200px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            color: #f0f0f0;
            position: relative;
        }

        .modal-content h2 {
            color: #ffa500;
            margin-top: 0;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
        }

        .close-button:hover,
        .close-button:focus {
            color: #ffa500;
            text-decoration: none;
            cursor: pointer;
        }

        .table-container {
            max-height: 60vh; /* Max height for scrollable table body */
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #555;
            border-radius: 44px;
        }

        #familyDataTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            table-layout: fixed; /* Ensures columns respect width */
        }

        #familyDataTable th, #familyDataTable td {
            border: 1px solid #555;
            padding: 8px;
            text-align: left;
            white-space: nowrap; /* Prevent wrapping by default */
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #familyDataTable th {
            background-color: #444;
            color: #f0f0f0;
            position: sticky; /* Sticky headers for scrolling */
            top: 0;
            z-index: 1;
        }

        #familyDataTable tbody tr:nth-child(even) {
            background-color: #3a3a3a;
        }

        #familyDataTable tbody tr:hover {
            background-color: #4a4a4a;
        }
        
        #familyDataTable tbody tr.selected-row {
            background-color: #007bff; /* Highlight color for selected row */
            color: white;
        }

        #familyDataTable [contenteditable="true"] {
            outline: 1px dashed #ffa500;
            min-width: 50px; /* Ensure editable cells have a minimum size */
            white-space: normal; /* Allow text to wrap within editable cells */
            word-break: break-all; /* Break long words */
        }

        #familyDataTable td:nth-child(1) { width: 5%; } /* ID */
        #familyDataTable td:nth-child(2) { width: 15%; } /* Name */
        #familyDataTable td:nth-child(3),
        #familyDataTable td:nth-child(4) { width: 8%; } /* Years */
        #familyDataTable td:nth-child(5),
        #familyDataTable td:nth-child(6) { width: 10%; } /* Parent IDs */
        #familyDataTable td:nth-child(7) { width: 30%; } /* Image URL */
        #familyDataTable td:nth-child(8) { width: 10%; } /* X Position */

        .modal button {
            background-color: #ffa500;
            color: #1a1a1a;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.2s ease;
            margin-right: 10px;
            margin-top: 15px;
        }
        .modal button:hover {
            background-color: #e69500;
        }
    </style>
</head>
<body>
    <h1>Family Tree Maker</h1>

    <div class="controls">

        <div class="control-section">
            <h3 onclick="toggleSection(this)">File Operations <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <button onclick="exportToCsv()">Export to CSV</button>
                <input type="file" id="importCsvFile" accept=".csv" class="hidden-file-input" onchange="importFromCsv()">
                <button onclick="document.getElementById('importCsvFile').click()">Import from CSV</button>
                <select id="exampleFamilySelect" onchange="loadFamilyFromSelectedExample()">
                    <option value="">Load Example Family</option>
                    <option value="cleopatra_family.csv">Cleopatra</option>
                    <option value="queen_victoria_family.csv">Queen Victoria</option>
                    <option value="asgard_family.csv">Asgard</option>
                </select>
                <button onclick="clearTree()">Clear Tree</button>
                <button onclick="openEditTableModal()">Edit as Table</button>
            </div>
        </div>

        <div class="control-section">
            <h3 onclick="toggleSection(this)">Person Data & Actions <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <input type="text" id="personName" placeholder="Name" required>
                <input type="number" id="birthYear" placeholder="Birth Year" min="-100000" max="100000">
                <input type="number" id="deathYear" placeholder="Death Year (optional)" min="-100000" max="100000">
                <select id="parent1Select">
                    <option value="">Parent 1 (None)</option>
                </select>
                <select id="parent2Select">
                    <option value="">Parent 2 (None)</option>
                </select>
                <button id="addUpdateBtn" onclick="addUpdatePerson()">Add Person</button>
                <button id="removePersonBtn" onclick="removePerson()" disabled>Remove Person</button>
            </div>
        </div>

        <div class="control-section">
            <h3 onclick="toggleSection(this)">Image Management <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <input type="text" id="imageUrlInput" placeholder="Image URL">
                <button id="linkImageBtn" onclick="linkImage()" disabled>Link Image</button>
                <input type="file" id="imageFileInput" accept="image/*" class="hidden-file-input" onchange="handleImageUpload()">
                <button id="loadImageBtn" onclick="document.getElementById('imageFileInput').click()" disabled>Load Image</button>
                <button id="removeImageBtn" onclick="removeImage()" disabled>Remove Image</button>
            </div>
        </div>

        <div class="control-section">
            <h3 onclick="toggleSection(this)">Tree View & Layout <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <label for="verticalDistanceSlider">Vertical Distance:</label>
                <input type="range" id="verticalDistanceSlider" min="1" max="100" value="8" step="0.5" onchange="updateVerticalDistance()" oninput="updateVerticalDistance()">
                <span id="currentVerticalDistance" class="zoom-label">3.0x</span>
                
                <label for="imageSizeInput">Image Size:</label>
                <input type="range" id="imageSizeInput" min="10" max="1000" value="40" step="5" onchange="updateImageSize()" oninput="updateImageSize()">
                <span id="currentImageSize" class="zoom-label">40px</span>

                <label for="treeScaleSlider">Tree Scale:</label>
                <input type="range" id="treeScaleSlider" min="0.5" max="20.0" value="1.0" step="0.1" onchange="updateTreeScale()" oninput="updateTreeScale()">
                <span id="currentTreeScale" class="zoom-label">1.0x</span>

                <button onclick="toggleLifelines()">Toggle Lifelines</button>
                <button onclick="toggleYearLines()">Toggle Year Lines</button>
                <button onclick="rotateTree()">Rotate Tree</button>
                <button onclick="saveAsJpg()">Save to JPG</button>
            </div>
        </div>

        <div class="control-section">
            <h3 onclick="toggleSection(this)">Background Customization <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <input type="file" id="bgImageFileInput" accept="image/*, .gif" class="hidden-file-input" onchange="handleBackgroundUpload()">
                <button onclick="document.getElementById('bgImageFileInput').click()">Add Background Image</button>
                <button id="removeBgImageBtn" onclick="removeBackgroundImage()" disabled>Remove Background Image</button>
                
                <label for="bgSizeSlider">BG Size:</label>
                <input type="range" id="bgSizeSlider" min="10" max="200" value="100" step="5" onchange="updateBackgroundStyle()" oninput="updateBackgroundStyle()">
                <span id="currentBgSize" class="zoom-label">100%</span>
                
                <label for="bgPosXSlider">BG Pos X:</label>
                <input type="range" id="bgPosXSlider" min="-200" max="200" value="0" step="1" onchange="updateBackgroundStyle()" oninput="updateBackgroundStyle()">
                <span id="currentBgPosX" class="zoom-label">0%</span>
                
                <label for="bgPosYSlider">BG Pos Y:</label>
                <input type="range" id="bgPosYSlider" min="-200" max="200" value="0" step="1" onchange="updateBackgroundStyle()" oninput="updateBackgroundStyle()">
                <span id="currentBgPosY" class="zoom-label">0%</span>

                <label for="treeBgColorPicker">BG Color:</label>
                <input type="color" id="treeBgColorPicker" value="#2b2b2b" onchange="updateTreeBgColor()">
            </div>
        </div>

        <div class="control-section">
            <h3 onclick="toggleSection(this)">Text Customization <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <label for="fontSizeSlider">Font Size:</label>
                <input type="range" id="fontSizeSlider" min="8" max="300" value="18" step="1" onchange="updateFontSize()" oninput="updateFontSize()">
                <span id="currentFontSize" class="zoom-label">12px</span>

                <label for="fontColorPicker">Font Color:</label>
                <input type="color" id="fontColorPicker" value="#f0f0f0" onchange="updateFontColor()">

                <label for="fontBgColorPicker">Font BG Color:</label>
                <input type="color" id="fontBgColorPicker" value="#00000000" onchange="updateFontBackgroundColor()">
                <button id="removeFontBgColorBtn" onclick="removeFontBackgroundColor()">Remove Font BG Color</button>

                <input type="text" id="fontFamilyInput" placeholder="Font Name (e.g., Arial, 'Times New Roman')">
                <button id="loadFontBtn" onclick="loadFontFamily()">Load Font</button>

                <label for="verticalTextOffsetSlider">Text Vert. Offset:</label>
                <input type="range" id="verticalTextOffsetSlider" min="-50" max="50" value="0" step="1" onchange="updateVerticalTextOffset()" oninput="updateVerticalTextOffset()">
                <span id="currentVerticalTextOffset" class="zoom-label">0px</span>

                <label for="textHorizontalOffsetSlider">Text Horiz. Offset:</label>
                <input type="range" id="textHorizontalOffsetSlider" min="-100" max="100" value="0" step="1" onchange="updateTextHorizontalOffset()" oninput="updateTextHorizontalOffset()">
                <span id="currentTextHorizontalOffset" class="zoom-label">0px</span>
            </div>
        </div>

        <div class="control-section">
            <h3 onclick="toggleSection(this)">Box Customization <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <label for="boxColorPicker">Box Fill:</label>
                <input type="color" id="boxColorPicker" value="#444444" onchange="updateBoxColor()">

                <label for="boxLineColorPicker">Box Line:</label>
                <input type="color" id="boxLineColorPicker" value="#ffa500" onchange="updateBoxLineColor()">

                <label for="lineColorPicker">Line Color:</label>
                <input type="color" id="lineColorPicker" value="#ffa500" onchange="updateLineColor()">

                <label for="lineThicknessSlider">Line Thickness:</label>
                <input type="range" id="lineThicknessSlider" min="1" max="10" value="2" step="0.5" onchange="updateLineThickness()" oninput="updateLineThickness()">
                <span id="currentLineThickness" class="zoom-label">2.0px</span>

                <label for="boxRectWidthSlider">Box Width:</label>
                <input type="range" id="boxRectWidthSlider" min="100" max="300" value="180" step="10" onchange="updateBoxRectWidth()" oninput="updateBoxRectWidth()">
                <span id="currentBoxRectWidth" class="zoom-label">180px</span>

                <label for="boxRectHeightSlider">Rect Height:</label>
                <input type="range" id="boxRectHeightSlider" min="50" max="300" value="180" step="10" onchange="updateBoxRectHeight()" oninput="updateBoxRectHeight()">
                <span id="currentBoxRectHeight" class="zoom-label">180px</span>

                <label for="boxShapeSelect">Box Shape:</label>
                <select id="boxShapeSelect" onchange="updateBoxShape()">
                    <option value="rectangle">Rectangle</option>
                    <option value="circle">Circle</option>
                </select>
            </div>
        </div>

        <div class="control-section">
            <h3 onclick="toggleSection(this)">Application Settings <span class="toggle-icon">▼</span></h3>
            <div class="control-section-content">
                <label for="skinSelect">Load Skin:</label>
                <select id="skinSelect" onchange="loadSkin()">
                    <option value="">-- Select a Skin --</option>
                    <option value="defaultDark">Default Dark</option>
                    <option value="lightClean">Light & Clean</option>
                    <option value="forestGreen">Forest Green</option>
                    <option value="oceanBlue">Ocean Blue</option>
                    <option value="vintageSepia">Vintage Sepia</option>
                    <option value="modernCircles">Modern Circles</option>
                </select>
                <button id="saveSettingsBtn" onclick="saveSettings()">Save Settings</button>
                <input type="file" id="loadSettingsFileInput" accept=".json" class="hidden-file-input" onchange="handleLoadSettingsFile()">
                <button id="loadSettingsBtn" onclick="document.getElementById('loadSettingsFileInput').click()">Load Settings</button>
            </div>
        </div>
    </div>

    <div class="tree-container" id="treeContainer">
        <svg id="familyTreeSvg"></svg>
        <div id="tooltip" class="tooltip"></div>
    </div>
    <div id="messageBox"></div>

    <!-- New: Edit as Table Modal -->
    <div id="editTableModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeEditTableModal()">&times;</span>
            <h2>Edit Family Data</h2>
            <div class="table-container">
                <table id="familyDataTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Birth Year</th>
                            <th>Death Year</th>
                            <th>Parent 1 ID</th>
                            <th>Parent 2 ID</th>
                            <th>Image URL</th>
                            <th>X Position</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be populated here by JavaScript -->
                    </tbody>
                </table>
            </div>
            <button onclick="saveTableChanges()">Save Changes</button>
            <button id="deleteSelectedRowBtn" onclick="deleteSelectedRow()" disabled>Delete Selected Row</button>
            <button onclick="insertNewRow()">Insert Row</button>
            <button onclick="closeEditTableModal()">Close</button>
        </div>
    </div>

    <script>
        let family = []; // Array to store person objects
        let nextPersonId = 1;
        let selectedPersonId = null; // Stores the ID of the currently selected person
        let showLifelines = false; // Controls lifeline visibility
        let showYearLines = true; // Controls year line visibility

        // Drag & Drop variables
        let isDragging = false;
        let draggedPersonId = null;
        let initialMouseX;
        let dragOffsetX = 0; // Stores the offset from node's left edge to mouse click point
        let draggedSvgGroup = null; // Reference to the SVG 'g' element being dragged

        // Rotation and Scaling variables
        let rotationAngle = 0; // In degrees, for CSS transform
        let treeScale = 1.0; // Scale factor for the entire tree

        // Configuration for SVG drawing
        let NODE_WIDTH = 180; // This will be set dynamically based on boxRectWidth
        const levelSpacingBaseUnit = 40; // Base unit for vertical spacing when no years (e.g., 40px per 'level' at 1x verticalScaleFactor)
        let imageSize = 40; // Initial size for the person's image, now variable
        let verticalScaleFactor = 8; // Controls vertical distance, formerly pixelsPerYear
        const YEAR_LINE_INTERVAL = 10; // Every 10 years
        const HORIZONTAL_SPACING = 30; // Horizontal space between nodes at the same approximate year level
        let TOP_PADDING = imageSize + 10; // Space above the earliest year for images and margin (now dynamic)
        const LIFELINE_OFFSET = 5; // Horizontal offset for the lifeline from the node's right edge

        // Background image variables
        let backgroundImageUrl = null;
        let backgroundSize = 100; // in percentage
        let backgroundPosX = 0;   // in percentage
        let backgroundPosY = 0;   // in percentage

        // Customization variables
        let fontSize = 22;
        let fontColor = '#f0f0f0';
        let fontBackgroundColor = 'transparent'; // Default font background color (transparent)
        let fontFamily = 'Arial, sans-serif'; // Default font
        let boxColor = '#444444';
        let boxLineColor = '#ffa500'; // Default box line color
        let lineColor = '#ffa500'; // Default connecting line color
        let lineThickness = 2; // NEW: Default line thickness
        let boxRectWidth = 180; // Width for rect, diameter for circle
        let boxRectHeight = 180; // Height for rectangle boxes
        let boxShape = 'rectangle'; // 'rectangle' or 'circle'
        let treeBackgroundColor = '#2b2b2b'; // Default tree container background color
        let verticalTextOffset = 0; // Vertical offset for text position
        let textHorizontalOffset = 0; // Horizontal offset for text position

        // Edit Table Modal
        let selectedTableRow = null; // To track the currently selected row in the modal table
        let nextTmpId = 1; // For new rows added in the table editor

        // Preset Skins
        const presetSkins = {
            defaultDark: {
                verticalScaleFactor: 3, imageSize: 40, fontSize: 12, fontColor: '#f0f0f0', fontBackgroundColor: 'transparent',
                fontFamily: 'Arial, sans-serif', boxColor: '#444444', boxLineColor: '#ffa500', lineColor: '#ffa500', lineThickness: 2,
                boxRectWidth: 180, boxRectHeight: 180, boxShape: 'rectangle', treeBackgroundColor: '#2b2b2b',
                verticalTextOffset: 0, textHorizontalOffset: 0, showLifelines: false, showYearLines: true,
                rotationAngle: 0, treeScale: 1.0, backgroundImageUrl: null, backgroundSize: 100, backgroundPosX: 0, backgroundPosY: 0
            },
            lightClean: {
                verticalScaleFactor: 3, imageSize: 50, fontSize: 14, fontColor: '#000000', fontBackgroundColor: '#ffffffcc',
                fontFamily: 'Verdana, sans-serif', boxColor: '#e0e0e0', boxLineColor: '#6699ff', lineColor: '#6699ff', lineThickness: 2,
                boxRectWidth: 200, boxRectHeight: 100, boxShape: 'rectangle', treeBackgroundColor: '#f8f8f8',
                verticalTextOffset: 0, textHorizontalOffset: 0, showLifelines: true, showYearLines: true,
                rotationAngle: 0, treeScale: 1.0, backgroundImageUrl: null, backgroundSize: 100, backgroundPosX: 0, backgroundPosY: 0
            },
            forestGreen: {
                verticalScaleFactor: 2.5, imageSize: 60, fontSize: 13, fontColor: '#e0ffe0', fontBackgroundColor: '#224422cc',
                fontFamily: 'Georgia, serif', boxColor: '#3a6a3a', boxLineColor: '#aaffaa', lineColor: '#aaffaa', lineThickness: 3,
                boxRectWidth: 190, boxRectHeight: 90, boxShape: 'rectangle', treeBackgroundColor: '#2b502b',
                verticalTextOffset: 0, textHorizontalOffset: 0, showLifelines: true, showYearLines: false,
                rotationAngle: 0, treeScale: 1.0, backgroundImageUrl: null, backgroundSize: 100, backgroundPosX: 0, backgroundPosY: 0
            },
            oceanBlue: {
                verticalScaleFactor: 3.5, imageSize: 45, fontSize: 12, fontColor: '#e0f2f7', fontBackgroundColor: '#1a4c68cc',
                fontFamily: '"Trebuchet MS", sans-serif', boxColor: '#2a628f', boxLineColor: '#6fcffb', lineColor: '#6fcffb', lineThickness: 2.5,
                boxRectWidth: 170, boxRectHeight: 110, boxShape: 'rectangle', treeBackgroundColor: '#1d3e53',
                verticalTextOffset: 0, textHorizontalOffset: 0, showLifelines: true, showYearLines: true,
                rotationAngle: 0, treeScale: 1.0, backgroundImageUrl: null, backgroundSize: 100, backgroundPosX: 0, backgroundPosY: 0
            },
            vintageSepia: {
                verticalScaleFactor: 4, imageSize: 55, fontSize: 15, fontColor: '#000000', fontBackgroundColor: '#f8f0e0b3',
                fontFamily: '"Times New Roman", serif', boxColor: '#d4b79b', boxLineColor: '#8a6e4d', lineColor: '#8a6e4d', lineThickness: 1.5,
                boxRectWidth: 210, boxRectHeight: 130, boxShape: 'rectangle', treeBackgroundColor: '#f0e6d6',
                verticalTextOffset: 0, textHorizontalOffset: 0, showLifelines: false, showYearLines: true,
                rotationAngle: 0, treeScale: 1.0, backgroundImageUrl: null, backgroundSize: 100, backgroundPosX: 0, backgroundPosY: 0
            },
            modernCircles: {
                verticalScaleFactor: 3, imageSize: 70, fontSize: 16, fontColor: '#ffffff', fontBackgroundColor: '#555555cc',
                fontFamily: '"Open Sans", sans-serif', boxColor: '#666666', boxLineColor: '#cc00ff', lineColor: '#cc00ff', lineThickness: 4,
                boxRectWidth: 150, boxRectHeight: 150, boxShape: 'circle', treeBackgroundColor: '#3a3a3a',
                verticalTextOffset: 0, textHorizontalOffset: 0, showLifelines: true, showYearLines: false,
                rotationAngle: 0, treeScale: 1.0, backgroundImageUrl: null, backgroundSize: 100, backgroundPosX: 0, backgroundPosY: 0
            }
        };


        function generateId() {
            return 'p' + (nextPersonId++);
        }
        
        function generateTmpId() {
            return 'tmp_p' + (nextTmpId++);
        }

        // Show temporary message function
        function showMessage(message) {
            const msgBox = document.getElementById('messageBox');
            msgBox.textContent = message;
            msgBox.classList.add('visible');
            setTimeout(() => {
                msgBox.classList.remove('visible');
            }, 3000); // Hide after 3 seconds
        }

        function clearTree() {
            family = [];
            nextPersonId = 1;
            selectedPersonId = null;
            updateParentSelect();
            drawFamilyTree();
            resetFormAndSelection();
            document.getElementById('exampleFamilySelect').value = ""; // Reset dropdown
            showMessage('Tree cleared.');
        }

        function updateParentSelect() {
            const parent1Select = document.getElementById('parent1Select');
            const parent2Select = document.getElementById('parent2Select');
            parent1Select.innerHTML = '<option value="">Parent 1 (None)</option>'; // Clear existing options
            parent2Select.innerHTML = '<option value="">Parent 2 (None)</option>'; // Clear existing options

            family.forEach(person => {
                // Don't let a person be their own parent in the dropdown
                if (person.id !== selectedPersonId) {
                    const option1 = document.createElement('option');
                    option1.value = person.id;
                    option1.textContent = `${person.name} (${person.birthYear || '?'})`;
                    parent1Select.appendChild(option1);

                    const option2 = document.createElement('option');
                    option2.value = person.id;
                    option2.textContent = `${person.name} (${person.birthYear || '?'})`;
                    parent2Select.appendChild(option2);
                }
            });

            // If we are editing, ensure the current parents are selected
            if (selectedPersonId) {
                const personToEdit = family.find(p => p.id === selectedPersonId);
                if (personToEdit) {
                    parent1Select.value = personToEdit.parent1Id || '';
                    parent2Select.value = personToEdit.parent2Id || '';
                }
            }
        }

        function addUpdatePerson() {
            const name = document.getElementById('personName').value.trim();
            const birthYearInput = document.getElementById('birthYear').value;
            const birthYear = birthYearInput ? parseInt(birthYearInput) : null;
            const deathYearInput = document.getElementById('deathYear').value;
            const deathYear = deathYearInput ? parseInt(deathYearInput) : null;
            const parent1Id = document.getElementById('parent1Select').value || null;
            const parent2Id = document.getElementById('parent2Select').value || null;


            if (!name) {
                alert('Please enter a name.');
                return;
            }
            if (birthYearInput && isNaN(birthYear)) {
                alert('Please enter a valid birth year or leave blank.');
                return;
            }
            if (deathYearInput && isNaN(deathYear)) {
                alert('Please enter a valid death year or leave blank.');
                return;
            }
            if (birthYear !== null && deathYear !== null && birthYear >= deathYear) {
                alert('Birth year must be before death year.');
                return;
            }
            // Check for a person being their own parent in the form
            if (selectedPersonId && (parent1Id === selectedPersonId || parent2Id === selectedPersonId)) {
                alert("A person cannot be their own direct parent.");
                return;
            }
            // Prevent same person selected as both parents
            if (parent1Id && parent2Id && parent1Id === parent2Id) {
                alert("Cannot select the same person for both Parent 1 and Parent 2.");
                return;
            }

            // Basic check for circular parentage (single level for simplicity)
            if (selectedPersonId) {
                const currentPerson = family.find(p => p.id === selectedPersonId);
                const checkCircular = (childId, potentialParentId) => {
                    if (!potentialParentId) return false;
                    let current = family.find(p => p.id === potentialParentId);
                    const visited = new Set();
                    while (current) {
                        if (current.id === childId) return true;
                        if (visited.has(current.id)) break; // Prevent infinite loop on complex graphs
                        visited.add(current.id);
                        
                        let nextParent = null;
                        if (current.parent1Id && !visited.has(current.parent1Id)) {
                            nextParent = family.find(p => p.id === current.parent1Id);
                        } else if (current.parent2Id && !visited.has(current.parent2Id)) {
                            nextParent = family.find(p => p.id === current.parent2Id);
                        }
                        current = nextParent;
                    }
                    return false;
                };

                if (checkCircular(selectedPersonId, parent1Id) || checkCircular(selectedPersonId, parent2Id)) {
                    alert("Circular parentage detected! Cannot set this parent.");
                    return;
                }
            }


            if (selectedPersonId) {
                // Update existing person
                const personToUpdate = family.find(p => p.id === selectedPersonId);
                if (personToUpdate) {
                    personToUpdate.name = name;
                    personToUpdate.birthYear = birthYear;
                    personToUpdate.deathYear = deathYear;
                    personToUpdate.parent1Id = parent1Id;
                    personToUpdate.parent2Id = parent2Id;
                    // personToUpdate.x is preserved if manually set, not reset to null here
                }
                showMessage('Person updated successfully!');
            } else {
                // Add new person
                const newPerson = {
                    id: generateId(),
                    name: name,
                    birthYear: birthYear,
                    deathYear: deathYear,
                    parent1Id: parent1Id,
                    parent2Id: parent2Id,
                    imageUrl: null, // New persons start without an image
                    x: null // Not manually positioned yet, will be auto-calculated
                };
                family.push(newPerson);
                showMessage('Person added successfully!');
            }

            updateParentSelect();
            drawFamilyTree();
            resetFormAndSelection();
        }

        function populateFormForEdit(person) {
            document.getElementById('personName').value = person.name;
            document.getElementById('birthYear').value = person.birthYear === null ? '' : person.birthYear;
            document.getElementById('deathYear').value = person.deathYear === null ? '' : person.deathYear;
            document.getElementById('imageUrlInput').value = person.imageUrl || ''; // Populate image URL input
            
            updateParentSelect(); // Re-populate to exclude self and select current parents
            document.getElementById('parent1Select').value = person.parent1Id || '';
            document.getElementById('parent2Select').value = person.parent2Id || '';

            document.getElementById('addUpdateBtn').textContent = 'Update Person';
        }

        function resetFormAndSelection() {
            document.getElementById('personName').value = '';
            document.getElementById('birthYear').value = '';
            document.getElementById('deathYear').value = '';
            document.getElementById('parent1Select').value = ''; // Clear parent 1 select
            document.getElementById('parent2Select').value = ''; // Clear parent 2 select
            document.getElementById('imageUrlInput').value = ''; // Clear image URL input
            document.getElementById('addUpdateBtn').textContent = 'Add Person';
            clearSelectionHighlight();
            selectedPersonId = null; 
            document.getElementById('loadImageBtn').disabled = true;
            document.getElementById('linkImageBtn').disabled = true; // Disable link image button
            document.getElementById('removePersonBtn').disabled = true; // Disable remove person button
            document.getElementById('removeImageBtn').disabled = true; // Disable remove image button on reset

            // Reset font family input (but not the actual value)
            document.getElementById('fontFamilyInput').value = '';
            document.getElementById('skinSelect').value = ''; // Reset skin dropdown
        }

        function selectPerson(id) {
            // Remove 'selected' class from previously selected node
            clearSelectionHighlight();

            selectedPersonId = id;

            // Add 'selected' class to the newly selected node
            if (selectedPersonId) {
                const currentSelectedNode = document.querySelector(`.person-node[data-id="${selectedPersonId}"]`);
                if (currentSelectedNode) {
                    currentSelectedNode.classList.add('selected');
                }
                const person = family.find(p => p.id === selectedPersonId);
                if (person) {
                    populateFormForEdit(person);
                    document.getElementById('loadImageBtn').disabled = false;
                    document.getElementById('linkImageBtn').disabled = false; // Enable link image button
                    document.getElementById('removePersonBtn').disabled = false; // Enable remove person button
                    document.getElementById('removeImageBtn').disabled = !person.imageUrl; 
                }
            } else {
                // If selection cleared, reset form and buttons
                resetFormAndSelection();
            }
            updateParentSelect(); // Update dropdown based on current selection
        }

        function clearSelectionHighlight() {
            const prevSelectedNode = document.querySelector('.person-node.selected');
            if (prevSelectedNode) {
                prevSelectedNode.classList.remove('selected');
            }
        }

        function clearSelection() {
            selectPerson(null);
        }

        function handleImageUpload() {
            const fileInput = document.getElementById('imageFileInput');
            const file = fileInput.files[0];

            if (!file) return;
            if (!selectedPersonId) {
                alert('Please select a person first.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const personToUpdate = family.find(p => p.id === selectedPersonId);
                if (personToUpdate) {
                    personToUpdate.imageUrl = e.target.result;
                    document.getElementById('imageUrlInput').value = e.target.result; // Update URL input too
                    drawFamilyTree(); // Redraw with the new image
                    showMessage(`Image loaded for ${personToUpdate.name}.`);
                    document.getElementById('removeImageBtn').disabled = false; // Enable remove image button
                }
            };
            reader.readAsDataURL(file);
            fileInput.value = ''; // Clear file input
        }

        function linkImage() {
            const imageUrl = document.getElementById('imageUrlInput').value.trim();
            if (!imageUrl) {
                alert('Please enter an image URL.');
                return;
            }
            if (!selectedPersonId) {
                alert('Please select a person first.');
                return;
            }

            const personToUpdate = family.find(p => p.id === selectedPersonId);
            if (personToUpdate) {
                personToUpdate.imageUrl = imageUrl;
                drawFamilyTree();
                showMessage(`Image linked for ${personToUpdate.name}.`);
                document.getElementById('removeImageBtn').disabled = false; // Enable remove image button
            }
        }

        function removeImage() {
            if (!selectedPersonId) {
                alert('Please select a person first.');
                return;
            }

            const personToUpdate = family.find(p => p.id === selectedPersonId);
            if (personToUpdate) {
                personToUpdate.imageUrl = null;
                document.getElementById('imageUrlInput').value = '';
                drawFamilyTree();
                showMessage(`Image removed for ${personToUpdate.name}.`);
                document.getElementById('removeImageBtn').disabled = true; // Disable after removal
            }
        }

        // Background Image functions
        function handleBackgroundUpload() {
            const fileInput = document.getElementById('bgImageFileInput');
            const file = fileInput.files[0];

            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                backgroundImageUrl = e.target.result;
                updateBackgroundStyle(); // Apply the new image and current slider settings
                document.getElementById('removeBgImageBtn').disabled = false;
                showMessage('Background image loaded!');
            };
            reader.readAsDataURL(file);
            fileInput.value = ''; // Clear file input
        }

        function removeBackgroundImage() {
            backgroundImageUrl = null;
            updateBackgroundStyle(); // Apply the change
            document.getElementById('removeBgImageBtn').disabled = true;
            showMessage('Background image removed.');
        }

        function updateBackgroundStyle() {
            const treeContainer = document.getElementById('treeContainer');
            
            backgroundSize = parseInt(document.getElementById('bgSizeSlider').value);
            backgroundPosX = parseInt(document.getElementById('bgPosXSlider').value);
            backgroundPosY = parseInt(document.getElementById('bgPosYSlider').value);

            document.getElementById('currentBgSize').textContent = `${backgroundSize}%`;
            document.getElementById('currentBgPosX').textContent = `${backgroundPosX}%`;
            document.getElementById('currentBgPosY').textContent = `${backgroundPosY}%`;

            if (backgroundImageUrl) {
                treeContainer.style.backgroundImage = `url('${backgroundImageUrl}')`;
                treeContainer.style.backgroundRepeat = 'no-repeat';
                treeContainer.style.backgroundSize = `${backgroundSize}%`;
                treeContainer.style.backgroundPosition = `${backgroundPosX}% ${backgroundPosY}%`;
            } else {
                treeContainer.style.backgroundImage = 'none';
                treeContainer.style.backgroundSize = 'auto';
                treeContainer.style.backgroundPosition = '0 0';
            }
        }

        function updateTreeBgColor() {
            treeBackgroundColor = document.getElementById('treeBgColorPicker').value;
            document.getElementById('treeContainer').style.backgroundColor = treeBackgroundColor;
            // drawFamilyTree(); // No need to redraw, only container style changes
        }

        function showParentTooltip(event, personId) {
            const person = family.find(p => p.id === personId);
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('visible'); // Hide previous tooltip if any

            if (!person || (!person.parent1Id && !person.parent2Id)) {
                return; // No parents to show
            }

            let tooltipText = [];
            if (person.parent1Id) {
                const parent1 = family.find(p => p.id === person.parent1Id);
                if (parent1) tooltipText.push(`Parent 1: ${parent1.name} (${parent1.birthYear || '?'})`);
            }
            if (person.parent2Id) {
                const parent2 = family.find(p => p.id === person.parent2Id);
                if (parent2) tooltipText.push(`Parent 2: ${parent2.name} (${parent2.birthYear || '?'})`);
            }
            
            if (tooltipText.length > 0) {
                tooltip.innerHTML = tooltipText.join('<br>');
                tooltip.style.color = fontColor; // Apply font color to tooltip
                tooltip.style.fontSize = `${fontSize * 0.9}px`; // Slightly smaller for tooltip
                tooltip.style.backgroundColor = boxColor; // Apply box color as tooltip background
                tooltip.style.borderColor = boxLineColor; // Apply box line color as tooltip border
                
                const treeContainerRect = document.getElementById('treeContainer').getBoundingClientRect();
                const nodeRect = event.currentTarget.getBoundingClientRect(); // The SVG 'g' element
                
                // Position tooltip slightly above the node, centered horizontally
                tooltip.style.left = `${nodeRect.left - treeContainerRect.left + nodeRect.width / 2}px`;
                tooltip.style.top = `${nodeRect.top - treeContainerRect.top - tooltip.offsetHeight - 10}px`;
                
                tooltip.classList.add('visible');
            }
        }

        function hideParentTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('visible');
        }

        function updateVerticalDistance() { // RENAMED FUNCTION
            verticalScaleFactor = parseFloat(document.getElementById('verticalDistanceSlider').value);
            document.getElementById('currentVerticalDistance').textContent = `${verticalScaleFactor.toFixed(1)}x`;
            // Recalculate TOP_PADDING based on current imageSize and redraw
            TOP_PADDING = imageSize + 10;
            drawFamilyTree();
        }

        function updateImageSize() {
            imageSize = parseInt(document.getElementById('imageSizeInput').value);
            document.getElementById('currentImageSize').textContent = `${imageSize}px`;
            // Recalculate TOP_PADDING based on current imageSize and redraw
            TOP_PADDING = imageSize + 10;
            drawFamilyTree();
        }
        
        function toggleLifelines() {
            showLifelines = !showLifelines;
            drawFamilyTree();
            showMessage(`Lifelines ${showLifelines ? 'shown' : 'hidden'}.`);
        }

        function toggleYearLines() {
            showYearLines = !showYearLines;
            drawFamilyTree();
            showMessage(`Year lines ${showYearLines ? 'shown' : 'hidden'}.`);
        }

        // Function to update overall tree scale
        function updateTreeScale() {
            treeScale = parseFloat(document.getElementById('treeScaleSlider').value);
            document.getElementById('currentTreeScale').textContent = `${treeScale.toFixed(1)}x`;
            const svg = document.getElementById('familyTreeSvg');
            // Apply both rotation and scale as CSS transform
            svg.style.transform = `scale(${treeScale}) rotate(${rotationAngle}deg)`;
        }

        function rotateTree() {
            rotationAngle = (rotationAngle + 90) % 360;
            const svg = document.getElementById('familyTreeSvg');
            // Apply both rotation and scale as CSS transform
            svg.style.transform = `scale(${treeScale}) rotate(${rotationAngle}deg)`;
            showMessage(`Tree rotated to ${rotationAngle} degrees.`);
            drawFamilyTree(); // Redraw to apply inverse rotation to text elements, images, AND boxes
        }

        function removePerson() {
            if (!selectedPersonId) {
                alert('Please select a person to remove.');
                return;
            }

            const personToRemove = family.find(p => p.id === selectedPersonId);
            if (!personToRemove) {
                alert('Selected person not found.');
                return;
            }

            if (!confirm(`Are you sure you want to remove ${personToRemove.name}? This cannot be undone.`)) {
                return;
            }

            // Remove the person from the family array
            family = family.filter(p => p.id !== selectedPersonId);

            // Update parentIds of children of the removed person
            family.forEach(p => {
                if (p.parent1Id === personToRemove.id) {
                    p.parent1Id = null; 
                }
                if (p.parent2Id === personToRemove.id) {
                    p.parent2Id = null;
                }
            });

            showMessage(`${personToRemove.name} removed.`);
            drawFamilyTree();
            resetFormAndSelection(); // Clear selection and form
        }

        // Customization functions
        function updateFontSize() {
            fontSize = parseInt(document.getElementById('fontSizeSlider').value);
            document.getElementById('currentFontSize').textContent = `${fontSize}px`;
            drawFamilyTree();
        }

        function updateFontColor() {
            fontColor = document.getElementById('fontColorPicker').value;
            drawFamilyTree();
            // Update tooltip color as well
            document.getElementById('tooltip').style.color = fontColor;
        }

        function updateFontBackgroundColor() {
            fontBackgroundColor = document.getElementById('fontBgColorPicker').value;
            drawFamilyTree();
        }

        function removeFontBackgroundColor() {
            fontBackgroundColor = 'transparent';
            document.getElementById('fontBgColorPicker').value = '#00000000'; // Represents transparent in color pickers
            drawFamilyTree();
            showMessage('Font background color removed.');
        }

        function loadFontFamily() {
            const input = document.getElementById('fontFamilyInput').value.trim();
            if (input) {
                fontFamily = input;
                drawFamilyTree();
                showMessage(`Font set to '${fontFamily}'.`);
            } else {
                alert('Please enter a font family name.');
            }
        }

        function updateVerticalTextOffset() {
            verticalTextOffset = parseInt(document.getElementById('verticalTextOffsetSlider').value);
            document.getElementById('currentVerticalTextOffset').textContent = `${verticalTextOffset}px`;
            drawFamilyTree();
        }

        function updateTextHorizontalOffset() { // NEW FUNCTION
            textHorizontalOffset = parseInt(document.getElementById('textHorizontalOffsetSlider').value);
            document.getElementById('currentTextHorizontalOffset').textContent = `${textHorizontalOffset}px`;
            drawFamilyTree();
        }

        function updateBoxColor() {
            boxColor = document.getElementById('boxColorPicker').value;
            drawFamilyTree();
        }
        
        function updateBoxLineColor() {
            boxLineColor = document.getElementById('boxLineColorPicker').value;
            drawFamilyTree();
        }

        function updateLineColor() { 
            lineColor = document.getElementById('lineColorPicker').value;
            drawFamilyTree();
        }

        function updateLineThickness() { // NEW FUNCTION
            lineThickness = parseFloat(document.getElementById('lineThicknessSlider').value);
            document.getElementById('currentLineThickness').textContent = `${lineThickness.toFixed(1)}px`;
            drawFamilyTree();
        }

        function updateBoxRectWidth() {
            boxRectWidth = parseInt(document.getElementById('boxRectWidthSlider').value);
            document.getElementById('currentBoxRectWidth').textContent = `${boxRectWidth}px`;
            drawFamilyTree();
        }

        function updateBoxRectHeight() {
            boxRectHeight = parseInt(document.getElementById('boxRectHeightSlider').value);
            document.getElementById('currentBoxRectHeight').textContent = `${boxRectHeight}px`;
            drawFamilyTree();
        }

        function updateBoxShape() {
            boxShape = document.getElementById('boxShapeSelect').value;
            drawFamilyTree();
        }

        function loadSkin() { // NEW FUNCTION
            const skinName = document.getElementById('skinSelect').value;
            if (skinName && presetSkins[skinName]) {
                applySettings(presetSkins[skinName]);
                showMessage(`Skin "${skinName.replace(/([A-Z])/g, ' $1').trim()}" loaded!`); // Format name for message
            } else if (skinName) {
                showMessage('Selected skin not found or invalid.');
            }
            document.getElementById('skinSelect').value = ''; // Reset dropdown after selection
        }


        // --- Drag and Drop Functions ---
        const svgElement = document.getElementById('familyTreeSvg');
        svgElement.addEventListener('mousedown', startDrag);
        svgElement.addEventListener('mousemove', drag);
        svgElement.addEventListener('mouseup', endDrag);
        svgElement.addEventListener('mouseleave', endDrag); // End drag if mouse leaves SVG

        function getMouseSvgCoordinates(event) {
            const ctm = svgElement.getScreenCTM();
            // Invert the CTM to transform screen coordinates to SVG user coordinates
            if (ctm) {
                const inverseCTM = ctm.inverse();
                // Apply the inverse matrix to the clientX/Y
                const svgPoint = svgElement.createSVGPoint();
                svgPoint.x = event.clientX;
                svgPoint.y = event.clientY;
                const transformedPoint = svgPoint.matrixTransform(inverseCTM);
                return {
                    x: transformedPoint.x,
                    y: transformedPoint.y
                };
            }
            // Fallback if CTM is not available or inverse fails
            return { x: event.clientX, y: event.clientY };
        }


        function startDrag(event) {
            // Only drag on the person node (g element), not the background
            const targetNode = event.target.closest('.person-node');
            if (targetNode) {
                isDragging = true;
                draggedPersonId = targetNode.dataset.id;
                draggedSvgGroup = targetNode;
                targetNode.classList.add('dragging');

                const person = family.find(p => p.id === draggedPersonId);
                if (person) {
                    const mouseCoords = getMouseSvgCoordinates(event);
                    initialMouseX = mouseCoords.x;
                    
                    // Get the current translation X from the SVG group's transform attribute
                    const transform = draggedSvgGroup.getAttribute('transform');
                    const match = transform.match(/translate\(([^,]+)/);
                    let currentRenderedX = person.x; // Fallback to data model if parse fails
                    if (match && match[1]) {
                        currentRenderedX = parseFloat(match[1]);
                    }
                    
                    // Calculate the offset from the node's current rendered X position to the mouse X position
                    dragOffsetX = initialMouseX - currentRenderedX;
                }
            }
        }

        function drag(event) {
            if (!isDragging || !draggedPersonId) return;
            event.preventDefault(); // Prevent text selection etc.

            const mouseCoords = getMouseSvgCoordinates(event);
            // New person X is current mouse X minus the initial offset
            const newX = mouseCoords.x - dragOffsetX; 

            const person = family.find(p => p.id === draggedPersonId);
            if (person) {
                person.x = newX;
                drawFamilyTree(); // Redraw to update the lines dynamically
                // Re-apply dragging and selected class after redraw, as SVG elements are replaced
                const reDraggedNode = document.querySelector(`.person-node[data-id="${draggedPersonId}"]`);
                if (reDraggedNode) {
                    reDraggedNode.classList.add('dragging');
                    if (selectedPersonId === draggedPersonId) {
                        reDraggedNode.classList.add('selected');
                    }
                }
            }
        }

        function endDrag() {
            if (isDragging) {
                if (draggedSvgGroup) {
                    draggedSvgGroup.classList.remove('dragging');
                }
                isDragging = false;
                draggedPersonId = null;
                draggedSvgGroup = null;
            }
        }
        // --- End Drag and Drop Functions ---

        // Helper function to wrap text within a given width (without truncation)
        function getWrappedText(text, maxWidth, fontSize) {
            const svg = document.getElementById('familyTreeSvg');
            const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tempText.style.fontSize = `${fontSize}px`;
            tempText.style.fontFamily = fontFamily; // Use current fontFamily for measurement
            svg.appendChild(tempText); 

            const words = text.split(' ');
            let line = '';
            let lines = [];
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + (i > 0 ? ' ' : '') + words[i];
                tempText.textContent = testLine;
                if (tempText.getComputedTextLength() > maxWidth && i > 0) {
                    lines.push(line);
                    line = words[i];
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            
            svg.removeChild(tempText); // Remove the temporary text element
            return lines; // Return all lines without truncation
        }

        // Helper to measure text width
        function getTextWidth(text, fontSize, fontFamily) {
            const svg = document.getElementById('familyTreeSvg');
            const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tempText.style.fontSize = `${fontSize}px`;
            tempText.style.fontFamily = fontFamily;
            tempText.textContent = text;
            svg.appendChild(tempText);
            const width = tempText.getComputedTextLength();
            svg.removeChild(tempText);
            return width;
        }


        function drawFamilyTree() {
            const svg = document.getElementById('familyTreeSvg');
            svg.innerHTML = ''; // Clear existing SVG content

            // Determine NODE_WIDTH and actualNodeHeight based on shape and sliders
            if (boxShape === 'rectangle') {
                NODE_WIDTH = boxRectWidth;
            } else { // circle
                NODE_WIDTH = boxRectWidth; // Circles use width for diameter
            }
            // For drawing purposes, actualNodeHeight will be explicitly set based on shape.
            const nodeDrawingHeight = (boxShape === 'rectangle' ? boxRectHeight : boxRectWidth);


            if (family.length === 0) {
                return;
            }

            // Check if any person has a valid birthYear to determine if we should draw with years
            const hasYears = family.some(p => p.birthYear !== null && !isNaN(p.birthYear));

            // Calculate min/max years for vertical scaling and year lines (only if hasYears)
            let minYear = 0; // Default if no years
            let maxYear = 0; // Default if no years
            if (hasYears) {
                minYear = Math.min(...family.filter(p => p.birthYear !== null).map(p => p.birthYear));
                maxYear = Math.max(...family.filter(p => p.deathYear !== null).map(p => p.deathYear), new Date().getFullYear());
                minYear = Math.floor(minYear / YEAR_LINE_INTERVAL) * YEAR_LINE_INTERVAL; // Round down to nearest interval
                maxYear = Math.ceil(maxYear / YEAR_LINE_INTERVAL) * YEAR_LINE_INTERVAL;   // Round up to nearest interval
            }
            
            const svgContainerWidth = svg.parentElement.offsetWidth - 40; // Parent width minus padding
            
            // Create a map for easy lookup and to hold layout properties
            const peopleMap = new Map(family.map(p => [p.id, { ...p, children: [], y: 0, level: 0, actualNodeHeight: nodeDrawingHeight }]));

            // Build child references (a person can have two parents)
            family.forEach(person => {
                if (person.parent1Id && peopleMap.has(person.parent1Id)) {
                    peopleMap.get(person.parent1Id).children.push(peopleMap.get(person.id));
                }
                if (person.parent2Id && peopleMap.has(person.parent2Id)) {
                    // Avoid adding the same child twice if both parents are in the map
                    const parent1Children = peopleMap.get(person.parent1Id)?.children || [];
                    if (!peopleMap.get(person.parent1Id) || parent1Children.indexOf(peopleMap.get(person.id)) === -1) {
                         peopleMap.get(person.parent2Id).children.push(peopleMap.get(person.id));
                    }
                }
            });

            // Find root nodes (no parents in the current family)
            const rootNodes = Array.from(peopleMap.values()).filter(p => !p.parent1Id && !p.parent2Id);
            if (hasYears) {
                rootNodes.sort((a, b) => a.birthYear - b.birthYear); // Sort by birth year to keep older ones higher
            } else {
                 rootNodes.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically if no years
            }


            // Layout algorithm:
            // 1. Assign levels (generations)
            function assignLevel(person, level) {
                person.level = level;
                person.children.forEach(child => assignLevel(child, level + 1));
            }
            rootNodes.forEach(node => assignLevel(node, 0));

            // 2. Assign Y positions (top of the node aligns with birth year or level)
            // 3. Assign X positions, respecting manually set `person.x` or calculating if `null`.
            const xPositionsByLevel = {}; // Tracks the next available X position for each level if auto-calculating

            function assignXPositions(person) {
                if (hasYears) {
                    // Original Y position logic for when years are present
                    person.y = (person.birthYear - minYear) * verticalScaleFactor + TOP_PADDING;
                } else {
                    // NEW: Y position logic for when no years, using verticalScaleFactor
                    person.y = person.level * (verticalScaleFactor * levelSpacingBaseUnit) + TOP_PADDING;
                }

                if (person.x !== null) {
                    // If person.x is already set (e.g., by dragging or import), use it.
                    // Recursively position children based on their own rules
                    person.children.sort((a, b) => a.birthYear - b.birthYear); // Still sort children by birth year if available
                    person.children.forEach(child => assignXPositions(child));
                } else {
                    // Auto-calculate X position if not manually set
                    if (person.children.length === 0) {
                        // Leaf node: place at the next available X for its level
                        if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50; // Initial margin
                        
                        person.x = xPositionsByLevel[person.level];
                        xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                    } else if (person.parent1Id && person.parent2Id) {
                        // Try to center between two parents if both are known and laid out
                        const p1 = peopleMap.get(person.parent1Id);
                        const p2 = peopleMap.get(person.parent2Id);

                        if (p1 && p1.x !== null && p2 && p2.x !== null) {
                            person.x = (p1.x + p2.x) / 2 - NODE_WIDTH / 2;
                        } else if (p1 && p1.x !== null) {
                            person.x = p1.x; // Fallback to parent1's x if parent2 unknown
                        } else if (p2 && p2.x !== null) {
                            person.x = p2.x; // Fallback to parent2's x if parent1 unknown
                        } else {
                            // If parents not yet laid out or not found, place sequentially
                            if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                        }
                    }
                    else if (person.parent1Id) {
                         // Place relative to single parent
                         const p1 = peopleMap.get(person.parent1Id);
                         if (p1 && p1.x !== null) {
                            person.x = p1.x; // Start under parent
                         } else {
                            if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                         }
                    } else if (person.parent2Id) { // Fallback for only parent2 set
                         const p2 = peopleMap.get(person.parent2Id);
                         if (p2 && p2.x !== null) {
                            person.x = p2.x; // Start under parent
                         } else {
                            if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                         }
                    } else { // Truly a root node
                        if (!xPositionsByLevel[person.level]) xPositionsByLevel[person.level] = 50;
                        person.x = xPositionsByLevel[person.level];
                        xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                    }

                    // Ensure horizontal spacing for auto-placed nodes at the same level
                    if (person.x !== null) {
                        if (!xPositionsByLevel[person.level] || person.x > xPositionsByLevel[person.level]) {
                            xPositionsByLevel[person.level] = person.x + NODE_WIDTH + HORIZONTAL_SPACING;
                        } else {
                            // Adjust x if it overlaps with a previous node on the same level that was auto-placed
                            person.x = xPositionsByLevel[person.level];
                            xPositionsByLevel[person.level] += NODE_WIDTH + HORIZONTAL_SPACING;
                        }
                    }

                    // Recursively position children if this person's X was just determined
                    person.children.sort((a, b) => a.birthYear - b.birthYear);
                    person.children.forEach(child => assignXPositions(child));
                }
            }
            
            // Execute the layout for all nodes
            rootNodes.forEach(node => assignXPositions(node));


            // Determine overall SVG width and height needed based on calculated positions and actualNodeHeight
            let maxCalculatedX = 0;
            let maxCalculatedY = 0;
            Array.from(peopleMap.values()).forEach(p => {
                maxCalculatedX = Math.max(maxCalculatedX, p.x + NODE_WIDTH);
                maxCalculatedY = Math.max(maxCalculatedY, p.y + p.actualNodeHeight); // Use actualNodeHeight
            });

            // Increased padding for rotation (was 50, now NODE_WIDTH * 2 for more buffer)
            const paddingForRotation = NODE_WIDTH * 2;
            const finalSvgWidth = Math.max(svgContainerWidth, maxCalculatedX + paddingForRotation); 
            const finalSvgHeight = maxCalculatedY + paddingForRotation; // Add padding for bottom
            
            svg.setAttribute('viewBox', `0 0 ${finalSvgWidth} ${finalSvgHeight}`);
            svg.setAttribute('height', finalSvgHeight);
            // Apply overall SVG rotation and scale
            svg.style.transform = `scale(${treeScale}) rotate(${rotationAngle}deg)`;

            // Drawing year lines first (conditional)
            if (showYearLines && hasYears) {
                for (let year = minYear; year <= maxYear; year += YEAR_LINE_INTERVAL) {
                    const yPos = (year - minYear) * verticalScaleFactor + TOP_PADDING;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', yPos);
                    line.setAttribute('x2', finalSvgWidth);
                    line.setAttribute('y2', yPos);
                    line.setAttribute('class', 'year-line');
                    svg.appendChild(line);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const textX = finalSvgWidth - 20; // Adjusted for more clearance from right edge
                    const textY = yPos - 5;
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('class', 'year-label');
                    text.textContent = year;
                    text.style.fill = fontColor; // Apply font color
                    text.style.fontSize = `${fontSize}px`; // Apply font size
                    text.style.fontFamily = fontFamily; // Apply font family
                    // Apply inverse rotation around its own position
                    text.setAttribute('transform', `rotate(${-rotationAngle} ${textX} ${textY})`);
                    svg.appendChild(text);
                }
            }

            // Draw connections (lines) first, then nodes
            peopleMap.forEach(person => {
                // Draw line for Parent 1
                if (person.parent1Id && peopleMap.has(person.parent1Id)) {
                    const parent = peopleMap.get(person.parent1Id);
                    const parentCenterX = parent.x + NODE_WIDTH / 2;
                    const parentBottomY = parent.y + parent.actualNodeHeight;
                    const childCenterX = person.x + NODE_WIDTH / 2;
                    const childTopY = person.y;

                    const midY = parentBottomY + (childTopY - parentBottomY) / 2;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let path = `M ${parentCenterX} ${parentBottomY}
                                V ${midY}
                                H ${childCenterX}
                                V ${childTopY}`;
                    line.setAttribute('d', path);
                    line.setAttribute('class', 'person-line');
                    line.style.stroke = lineColor; // Apply line color
                    line.style.strokeWidth = `${lineThickness}px`; // NEW: Apply line thickness
                    svg.appendChild(line);
                }

                // Draw line for Parent 2
                if (person.parent2Id && peopleMap.has(person.parent2Id)) {
                    const parent = peopleMap.get(person.parent2Id);
                    const parentCenterX = parent.x + NODE_WIDTH / 2;
                    const parentBottomY = parent.y + parent.actualNodeHeight;
                    const childCenterX = person.x + NODE_WIDTH / 2;
                    const childTopY = person.y;

                    const midY = parentBottomY + (childTopY - parentBottomY) / 2;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let path = `M ${parentCenterX} ${parentBottomY}
                                V ${midY}
                                H ${childCenterX}
                                V ${childTopY}`;
                    line.setAttribute('d', path);
                    line.setAttribute('class', 'person-line');
                    line.style.stroke = lineColor; // Apply line color
                    line.style.strokeWidth = `${lineThickness}px`; // NEW: Apply line thickness
                    svg.appendChild(line);
                }
            });

            // Draw nodes
            peopleMap.forEach(person => {
                const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                nodeGroup.setAttribute('class', `person-node ${selectedPersonId === person.id ? 'selected' : ''}`);
                nodeGroup.setAttribute('data-id', person.id);
                // Translate to the top-left corner of the node
                nodeGroup.setAttribute('transform', `translate(${person.x}, ${person.y})`);
                nodeGroup.onclick = (e) => { e.stopPropagation(); selectPerson(person.id); }; // Select on click
                nodeGroup.onmouseover = (e) => showParentTooltip(e, person.id);
                nodeGroup.onmouseout = hideParentTooltip;

                let nodeElement;
                let clipPathId = `clip-${person.id}`;
                const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                clipPath.setAttribute('id', clipPathId);

                if (boxShape === 'rectangle') {
                    nodeElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    nodeElement.setAttribute('x', 0);
                    nodeElement.setAttribute('y', 0);
                    nodeElement.setAttribute('width', NODE_WIDTH); // Use NODE_WIDTH (which is boxRectWidth)
                    nodeElement.setAttribute('height', nodeDrawingHeight); // Use nodeDrawingHeight (which is boxRectHeight)
                    nodeElement.setAttribute('rx', 5); // Rounded corners for rect
                    nodeElement.setAttribute('ry', 5);
                    // Add rect to clipPath
                    const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    clipRect.setAttribute('x', 0);
                    clipRect.setAttribute('y', 0);
                    clipRect.setAttribute('width', NODE_WIDTH);
                    clipRect.setAttribute('height', nodeDrawingHeight);
                    clipRect.setAttribute('rx', 5);
                    clipRect.setAttribute('ry', 5);
                    clipPath.appendChild(clipRect);
                } else { // Circle shape
                    nodeElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    const radius = NODE_WIDTH / 2; // Radius based on NODE_WIDTH (which is boxRectWidth)
                    nodeElement.setAttribute('cx', NODE_WIDTH / 2);
                    nodeElement.setAttribute('cy', nodeDrawingHeight / 2); // Center Y based on nodeDrawingHeight (which is boxRectWidth)
                    nodeElement.setAttribute('r', radius);
                    // Add circle to clipPath
                    const clipCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    clipCircle.setAttribute('cx', NODE_WIDTH / 2);
                    clipCircle.setAttribute('cy', nodeDrawingHeight / 2);
                    clipCircle.setAttribute('r', radius);
                    clipPath.appendChild(clipCircle);
                }

                nodeElement.style.fill = boxColor; // Apply box color
                nodeElement.style.stroke = boxLineColor; // Apply box line color
                // Calculate center of node element relative to nodeGroup's origin for rotation
                const nodeCenterX = NODE_WIDTH / 2;
                const nodeCenterY = nodeDrawingHeight / 2;
                nodeElement.setAttribute('transform', `rotate(${-rotationAngle} ${nodeCenterX} ${nodeCenterY})`);
                nodeGroup.appendChild(nodeElement);
                svg.appendChild(clipPath); // Append clipPath to SVG directly

                // Calculate content layout within the fixed box
                const contentWidth = NODE_WIDTH - 20; // 10px padding on each side
                const contentHeight = nodeDrawingHeight;

                const nameFontSize = fontSize;
                const yearsFontSize = fontSize;
                const nameLineHeight = nameFontSize * 1.2;
                const yearsLineHeight = yearsFontSize * 1.2;

                const wrappedNameLines = getWrappedText(person.name, contentWidth, nameFontSize);

                let yearsContent = '';
                if (hasYears) {
                    yearsContent = `${person.birthYear} - ${person.deathYear || 'Present'}`;
                } else {
                    if (person.birthYear && person.deathYear) {
                        yearsContent = `${person.birthYear} - ${person.deathYear}`;
                    } else if (person.birthYear) {
                        yearsContent = `Born: ${person.birthYear}`;
                    } else if (person.deathYear) {
                        yearsContent = `Died: ${person.deathYear}`;
                    }
                }
                
                let totalTextHeight = (wrappedNameLines.length * nameLineHeight);
                if (yearsContent) {
                    totalTextHeight += yearsLineHeight;
                }

                let textBlockStartY = (contentHeight - totalTextHeight) / 2;
                textBlockStartY += verticalTextOffset; // Apply vertical offset

                // Image positioning
                let imageElement = null;
                let imageX = 0;
                let imageY = 0;
                if (person.imageUrl) {
                    imageElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    imageElement.setAttribute('href', person.imageUrl);
                    imageX = (NODE_WIDTH - imageSize) / 2; 
                    imageY = (textBlockStartY - imageSize) / 2; 
                    if (imageY < 0) imageY = 5; 
                    
                    imageElement.setAttribute('x', imageX); 
                    imageElement.setAttribute('y', imageY); 
                    imageElement.setAttribute('width', imageSize);
                    imageElement.setAttribute('height', imageSize);
                    imageElement.setAttribute('class', 'node-image');
                    imageElement.setAttribute('clip-path', `url(#${clipPathId})`);

                    const imageCenterX = imageX + imageSize / 2;
                    const imageCenterY = imageY + imageSize / 2;
                    imageElement.setAttribute('transform', `rotate(${-rotationAngle} ${imageCenterX} ${imageCenterY})`);
                    nodeGroup.appendChild(imageElement);

                    textBlockStartY = imageY + imageSize + 10; 
                    if (textBlockStartY + totalTextHeight > contentHeight - 10) { 
                         textBlockStartY = contentHeight - totalTextHeight - 5; 
                         if (textBlockStartY < imageY + imageSize) textBlockStartY = imageY + imageSize + 5; 
                    }
                }


                wrappedNameLines.forEach((lineText, index) => {
                    const nameText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const nameTextWidth = getTextWidth(lineText, nameFontSize, fontFamily);
                    const nameTextX = NODE_WIDTH / 2 + textHorizontalOffset; // Centered + horizontal offset
                    const nameTextY = textBlockStartY + (index * nameLineHeight) + (nameLineHeight / 2);

                    // Background rectangle for text
                    if (fontBackgroundColor !== 'transparent') {
                        const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        // Center background rect around textX
                        bgRect.setAttribute('x', nameTextX - nameTextWidth / 2 - 5); 
                        bgRect.setAttribute('y', nameTextY - nameLineHeight / 2);
                        bgRect.setAttribute('width', nameTextWidth + 10); 
                        bgRect.setAttribute('height', nameLineHeight);
                        bgRect.style.fill = fontBackgroundColor; // Apply font background color as inline style
                        bgRect.style.stroke = 'none'; // Ensure no border for font background as inline style
                        // Apply inverse rotation around the center of the text
                        bgRect.setAttribute('transform', `rotate(${-rotationAngle} ${nameTextX} ${nameTextY})`);
                        nodeGroup.appendChild(bgRect);
                    }

                    nameText.setAttribute('x', nameTextX); 
                    nameText.setAttribute('y', nameTextY); 
                    nameText.textContent = lineText;
                    nameText.setAttribute('class', 'name-text'); 
                    nameText.style.fill = fontColor;
                    nameText.style.fontSize = `${fontSize}px`;
                    nameText.style.fontFamily = fontFamily;
                    // Apply inverse rotation around the center of the text
                    nameText.setAttribute('transform', `rotate(${-rotationAngle} ${nameTextX} ${nameTextY})`);
                    nodeGroup.appendChild(nameText);
                });

                if (yearsContent) {
                    const yearsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const yearsTextWidth = getTextWidth(yearsContent, yearsFontSize, fontFamily);
                    const yearsTextX = NODE_WIDTH / 2 + textHorizontalOffset; // Centered + horizontal offset
                    const yearsTextY = textBlockStartY + (wrappedNameLines.length * nameLineHeight) + (yearsLineHeight / 2);

                    // Background rectangle for text
                    if (fontBackgroundColor !== 'transparent') {
                        const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        // Center background rect around textX
                        bgRect.setAttribute('x', yearsTextX - yearsTextWidth / 2 - 5); 
                        bgRect.setAttribute('y', yearsTextY - yearsLineHeight / 2);
                        bgRect.setAttribute('width', yearsTextWidth + 10); 
                        bgRect.setAttribute('height', yearsLineHeight);
                        bgRect.style.fill = fontBackgroundColor; // Apply font background color as inline style
                        bgRect.style.stroke = 'none'; // Ensure no border for font background as inline style
                        // Apply inverse rotation around the center of the text
                        bgRect.setAttribute('transform', `rotate(${-rotationAngle} ${yearsTextX} ${yearsTextY})`);
                        nodeGroup.appendChild(bgRect);
                    }

                    yearsText.setAttribute('x', yearsTextX); 
                    yearsText.setAttribute('y', yearsTextY); 
                    yearsText.textContent = yearsContent;
                    yearsText.style.fill = fontColor;
                    yearsText.style.fontSize = `${fontSize}px`;
                    yearsText.style.fontFamily = fontFamily;
                    // Apply inverse rotation around the center of the text
                    yearsText.setAttribute('transform', `rotate(${-rotationAngle} ${yearsTextX} ${yearsTextY})`);
                    nodeGroup.appendChild(yearsText);
                }

                svg.appendChild(nodeGroup);

                // Draw lifeline if enabled
                if (showLifelines) {
                    const lifeline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    const lifelineX = person.x + NODE_WIDTH + LIFELINE_OFFSET;
                    
                    let lifelineY1, lifelineY2;
                    if (hasYears) {
                        const currentOrDeathYear = person.deathYear || new Date().getFullYear();
                        lifelineY1 = (person.birthYear - minYear) * verticalScaleFactor + TOP_PADDING;
                        lifelineY2 = (currentOrDeathYear - minYear) * verticalScaleFactor + TOP_PADDING;
                    } else {
                        // For year-less tree, lifelines just span the node height or fixed length
                        lifelineY1 = person.y;
                        lifelineY2 = person.y + person.actualNodeHeight;
                    }
                    

                    lifeline.setAttribute('x1', lifelineX);
                    lifeline.setAttribute('y1', lifelineY1);
                    lifeline.setAttribute('x2', lifelineX);
                    lifeline.setAttribute('y2', lifelineY2);
                    lifeline.setAttribute('class', 'lifeline');
                    svg.appendChild(lifeline);
                }
            });

            // Click on SVG background to clear selection
            svg.onclick = clearSelection;
        }

        // Helper to parse CSV content into family array
        function parseCsvContent(content) {
            const lines = content.split('\n').filter(line => line.trim() !== '');

            if (lines.length < 2) {
                console.warn('CSV file is empty or malformed.');
                return { family: [], maxIdNum: 0 };
            }

            const parseCsvLine = (line) => {
                const values = [];
                let inQuote = false;
                let currentVal = '';
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        if (i + 1 < line.length && line[i + 1] === '"') { // Escaped double quote
                            currentVal += '"';
                            i++; // Skip the next quote
                        } else {
                            inQuote = !inQuote;
                        }
                    } else if (char === ',' && !inQuote) {
                        values.push(currentVal);
                        currentVal = '';
                    } else {
                        currentVal += char;
                    }
                }
                values.push(currentVal); // Add the last value
                return values.map(v => v.trim()); // Trim whitespace
            };

            const headers = parseCsvLine(lines[0]);
            if (!headers.includes('ID') || !headers.includes('Name')) { // Relaxed BirthYear requirement for year-less trees
                console.error('CSV must contain "ID" and "Name" columns.');
                return { family: [], maxIdNum: 0 };
            }

            const newFamily = [];
            let maxIdNum = 0;

            for (let i = 1; i < lines.length; i++) {
                const values = parseCsvLine(lines[i]);
                if (values.length !== headers.length) {
                     console.warn(`Skipping malformed row (column count mismatch): ${lines[i]}`);
                     continue;
                }

                const person = {};
                headers.forEach((header, index) => {
                    const value = values[index];
                    if (header === 'ID') {
                        person.id = value;
                        const num = parseInt(value.substring(1));
                        if (!isNaN(num)) maxIdNum = Math.max(maxIdNum, num);
                    } else if (header === 'Name') {
                        person.name = value;
                    } else if (header === 'BirthYear') {
                        person.birthYear = value ? parseInt(value) : null;
                    } else if (header === 'DeathYear') {
                        person.deathYear = value ? parseInt(value) : null;
                    } else if (header === 'Parent1ID') {
                        person.parent1Id = value || null;
                    } else if (header === 'Parent2ID') {
                        person.parent2Id = value || null;
                    } else if (header === 'ImageURL') {
                        person.imageUrl = value || null;
                    } else if (header === 'XPosition') {
                        person.x = value ? parseFloat(value) : null;
                    }
                });

                if (person.id && person.name) { // Only require ID and Name
                    newFamily.push(person);
                } else {
                    console.warn('Skipping incomplete or invalid person data from CSV:', person);
                }
            }
            return { family: newFamily, maxIdNum: maxIdNum };
        }

        async function loadFamilyFromURL(url) {
            if (!url) {
                console.log("No example family selected.");
                clearTree(); // Clear existing tree if no selection
                return;
            }
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvContent = await response.text();
                
                const parsedData = parseCsvContent(csvContent);
                if (parsedData.family.length > 0) {
                    family = parsedData.family;
                    nextPersonId = parsedData.maxIdNum + 1;
                    updateParentSelect();
                    drawFamilyTree();
                    resetFormAndSelection();
                    showMessage(`'${url.split('/').pop().replace('_family.csv', '').replace(/_/g, ' ')}' family loaded successfully!`);
                } else {
                    alert(`Failed to load or parse data from ${url}.`);
                    clearTree();
                }
            } catch (error) {
                console.error('Error loading family data:', error);
                alert(`Could not load family data from ${url}. Make sure the file exists and is accessible.`);
                clearTree();
            }
        }

        function loadFamilyFromSelectedExample() {
            const selectElement = document.getElementById('exampleFamilySelect');
            const filename = selectElement.value; // e.g., "cleopatra_family.csv"
            
            if (filename) {
                loadFamilyFromURL(filename);
            } else {
                clearTree(); // If "Load Example Family" (empty value) is selected
            }
            // Reset dropdown to default "Load Example Family" after selection
            // This allows re-selecting the same family or choosing another.
            selectElement.value = ""; 
        }

        function importFromCsv() {
            const fileInput = document.getElementById('importCsvFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a CSV file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const parsedData = parseCsvContent(content); 
                
                if (parsedData.family.length > 0) {
                    family = parsedData.family;
                    nextPersonId = parsedData.maxIdNum + 1;
                    updateParentSelect();
                    drawFamilyTree();
                    resetFormAndSelection();
                    showMessage('Family tree imported successfully!');
                } else {
                    alert('Failed to import family tree from CSV.');
                }
            };

            reader.readAsText(file);
            fileInput.value = ''; // Clear the file input
        }

        // --- New Function: Export to CSV ---
        function exportToCsv() {
            if (family.length === 0) {
                alert('No family data to export.');
                return;
            }

            const headers = ["ID", "Name", "BirthYear", "DeathYear", "Parent1ID", "Parent2ID", "ImageURL", "XPosition"];
            // Quote headers to handle potential commas in header names (though not strictly needed here)
            let csvContent = headers.map(header => `"${header}"`).join(',') + '\n';

            family.forEach(person => {
                const row = headers.map(header => {
                    let value;
                    switch (header) {
                        case "ID":
                            value = person.id;
                            break;
                        case "Name":
                            value = person.name;
                            break;
                        case "BirthYear":
                            value = person.birthYear;
                            break;
                        case "DeathYear":
                            value = person.deathYear;
                            break;
                        case "Parent1ID":
                            value = person.parent1Id;
                            break;
                        case "Parent2ID":
                            value = person.parent2Id;
                            break;
                        case "ImageURL":
                            value = person.imageUrl;
                            break;
                        case "XPosition":
                            value = person.x;
                            break;
                        default:
                            value = ''; // Should not happen with defined headers
                    }

                    // Convert null/undefined to empty string for CSV, and ensure it's a string for processing
                    let stringValue = (value === null || typeof value === 'undefined') ? '' : String(value);

                    // Escape double quotes by replacing them with two double quotes, and wrap in quotes if value contains comma or double quote
                    if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) { // Added newline check for robustness
                        return `"${stringValue.replace(/"/g, '""')}"`;
                    }
                    return stringValue;
                }).join(',');
                csvContent += row + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection for download attribute
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'family_tree.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showMessage('Family tree exported to CSV!');
            } else {
                alert('Your browser does not support downloading files directly. Please copy the text below:\n\n' + csvContent);
            }
        }
        // --- End New Function: Export to CSV ---

        // New: Edit as Table functions
        function openEditTableModal() {
            populateEditTable();
            document.getElementById('editTableModal').style.display = 'block';
        }

        function closeEditTableModal() {
            document.getElementById('editTableModal').style.display = 'none';
            selectedTableRow = null;
            document.getElementById('deleteSelectedRowBtn').disabled = true;
        }

        function selectTableRow(row) {
            // Deselect previous row
            if (selectedTableRow) {
                selectedTableRow.classList.remove('selected-row');
            }
            // Select new row
            selectedTableRow = row;
            selectedTableRow.classList.add('selected-row');
            document.getElementById('deleteSelectedRowBtn').disabled = false;
        }

        function deleteSelectedRow() {
            if (selectedTableRow) {
                if (confirm(`Are you sure you want to delete person with ID ${selectedTableRow.dataset.id}?`)) {
                    selectedTableRow.remove();
                    selectedTableRow = null;
                    document.getElementById('deleteSelectedRowBtn').disabled = true;
                    showMessage('Row deleted from table (will be removed on save).');
                }
            } else {
                alert('Please select a row to delete.');
            }
        }

        function insertNewRow() {
            const tbody = document.getElementById('familyDataTable').querySelector('tbody');
            const row = tbody.insertRow();
            const tempId = generateTmpId(); // Use a temporary ID for new rows
            row.dataset.id = tempId;
            row.onclick = () => selectTableRow(row);

            row.insertCell().textContent = tempId; // ID column (not editable, placeholder)
            row.insertCell().innerHTML = `<div contenteditable="true" data-field="name">New Person</div>`;
            row.insertCell().innerHTML = `<div contenteditable="true" data-field="birthYear"></div>`;
            row.insertCell().innerHTML = `<div contenteditable="true" data-field="deathYear"></div>`;
            row.insertCell().innerHTML = `<div contenteditable="true" data-field="parent1Id"></div>`;
            row.insertCell().innerHTML = `<div contenteditable="true" data-field="parent2Id"></div>`;
            row.insertCell().innerHTML = `<div contenteditable="true" data-field="imageUrl"></div>`;
            row.insertCell().innerHTML = `<div contenteditable="true" data-field="x"></div>`;
            
            showMessage('New row inserted. Remember to save changes.');
            selectTableRow(row); // Automatically select the new row
        }


        function populateEditTable() {
            const tbody = document.getElementById('familyDataTable').querySelector('tbody');
            tbody.innerHTML = ''; // Clear existing rows
            selectedTableRow = null; // Clear any previous selection
            document.getElementById('deleteSelectedRowBtn').disabled = true;

            family.forEach(person => {
                const row = tbody.insertRow();
                row.dataset.id = person.id; // Store ID for easy lookup
                row.onclick = () => selectTableRow(row);

                row.insertCell().textContent = person.id; // ID column (not editable)
                row.insertCell().innerHTML = `<div contenteditable="true" data-field="name">${person.name}</div>`;
                row.insertCell().innerHTML = `<div contenteditable="true" data-field="birthYear">${person.birthYear === null ? '' : person.birthYear}</div>`;
                row.insertCell().innerHTML = `<div contenteditable="true" data-field="deathYear">${person.deathYear === null ? '' : person.deathYear}</div>`;
                row.insertCell().innerHTML = `<div contenteditable="true" data-field="parent1Id">${person.parent1Id || ''}</div>`;
                row.insertCell().innerHTML = `<div contenteditable="true" data-field="parent2Id">${person.parent2Id || ''}</div>`;
                row.insertCell().innerHTML = `<div contenteditable="true" data-field="imageUrl">${person.imageUrl || ''}</div>`;
                row.insertCell().innerHTML = `<div contenteditable="true" data-field="x">${person.x === null ? '' : person.x.toFixed(2)}</div>`;
            });
        }

        function saveTableChanges() {
            const tbody = document.getElementById('familyDataTable').querySelector('tbody');
            const newFamilyData = [];
            let currentMaxIdNum = 0;
            let tempIdMap = new Map(); // Map for temporary ID to new permanent ID

            // First pass: Process existing rows and assign new IDs for temporary ones
            for (const row of Array.from(tbody.rows)) {
                if (row.classList.contains('deleted-row')) continue; // Skip deleted rows

                const id = row.dataset.id;
                let finalId = id;

                // If it's a temporary ID, assign a new permanent one
                if (id.startsWith('tmp_p')) {
                    finalId = generateId(); // Use generateId to get the next sequential 'pX' ID
                    tempIdMap.set(id, finalId); // Map old temp ID to new permanent ID
                } else {
                    const num = parseInt(id.substring(1));
                    if (!isNaN(num)) currentMaxIdNum = Math.max(currentMaxIdNum, num);
                }
                
                const person = {
                    id: finalId,
                    name: row.querySelector('[data-field="name"]').textContent.trim(),
                    birthYear: row.querySelector('[data-field="birthYear"]').textContent.trim() ? parseInt(row.querySelector('[data-field="birthYear"]').textContent.trim()) : null,
                    deathYear: row.querySelector('[data-field="deathYear"]').textContent.trim() ? parseInt(row.querySelector('[data-field="deathYear"]').textContent.trim()) : null,
                    parent1Id: row.querySelector('[data-field="parent1Id"]').textContent.trim() || null,
                    parent2Id: row.querySelector('[data-field="parent2Id"]').textContent.trim() || null,
                    imageUrl: row.querySelector('[data-field="imageUrl"]').textContent.trim() || null,
                    x: row.querySelector('[data-field="x"]').textContent.trim() ? parseFloat(row.querySelector('[data-field="x"]').textContent.trim()) : null,
                };
                newFamilyData.push(person);
            }
            
            // Update nextPersonId based on the highest ID found/generated
            nextPersonId = currentMaxIdNum + 1;
            
            // Second pass: Update parent IDs with new permanent IDs if they referred to temporary ones
            newFamilyData.forEach(person => {
                if (person.parent1Id && tempIdMap.has(person.parent1Id)) {
                    person.parent1Id = tempIdMap.get(person.parent1Id);
                }
                if (person.parent2Id && tempIdMap.has(person.parent2Id)) {
                    person.parent2Id = tempIdMap.get(person.parent2Id);
                }
            });

            // Validate inputs
            const allIds = new Set(newFamilyData.map(p => p.id));
            for (const person of newFamilyData) {
                if (!person.name) {
                    showMessage(`Error: Name cannot be empty for ID ${person.id}.`);
                    return; 
                }
                if (person.birthYear !== null && isNaN(person.birthYear)) {
                    showMessage(`Error: Invalid Birth Year for ${person.name} (ID: ${person.id}). Must be a number or empty.`);
                    return;
                }
                if (person.deathYear !== null && isNaN(person.deathYear)) {
                    showMessage(`Error: Invalid Death Year for ${person.name} (ID: ${person.id}). Must be a number or empty.`);
                    return;
                }
                if (person.birthYear !== null && person.deathYear !== null && person.birthYear >= person.deathYear) {
                    showMessage(`Error: Birth year must be before death year for ${person.name} (ID: ${person.id}).`);
                    return;
                }
                if (person.x !== null && isNaN(person.x)) {
                    showMessage(`Error: Invalid X Position for ${person.name} (ID: ${person.id}). Must be a number or empty.`);
                    return;
                }
                // Check parent IDs against *final* set of IDs
                if (person.parent1Id && !allIds.has(person.parent1Id)) {
                    showMessage(`Error: Parent 1 ID "${person.parent1Id}" for ${person.name} (ID: ${person.id}) does not exist.`);
                    return;
                }
                if (person.parent2Id && !allIds.has(person.parent2Id)) {
                    showMessage(`Error: Parent 2 ID "${person.parent2Id}" for ${person.name} (ID: ${person.id}) does not exist.`);
                    return;
                }
                 if (person.id === person.parent1Id || person.id === person.parent2Id) {
                    showMessage(`Error: A person cannot be their own parent: ${person.name} (ID: ${person.id}).`);
                    return;
                }
                if (person.parent1Id && person.parent2Id && person.parent1Id === person.parent2Id) {
                    showMessage(`Error: Cannot select the same person for both Parent 1 and Parent 2 for ${person.name} (ID: ${person.id}).`);
                    return;
                }
            }


            family = newFamilyData;
            updateParentSelect();
            drawFamilyTree();
            resetFormAndSelection();
            showMessage('Family data updated from table!');
            closeEditTableModal();
        }

        function saveAsJpg() {
            const treeContainer = document.getElementById('treeContainer'); 

            if (!treeContainer || family.length === 0) {
                alert("No tree to save or SVG element not found.");
                return;
            }

            // Temporarily remove the selection highlight for a cleaner image
            const selectedNode = document.querySelector('.person-node.selected');
            if (selectedNode) selectedNode.classList.remove('selected');

            domtoimage.toJpeg(treeContainer, { quality: 0.95, bgcolor: treeBackgroundColor }) 
                .then(function (dataUrl) {
                    const link = document.createElement('a');
                    link.download = 'family_tree.jpg';
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showMessage('Family tree saved as JPG!');
                })
                .catch(function (error) {
                    console.error('Oops, something went wrong while saving as JPG!', error);
                    alert('Failed to save as JPG. Check console for details. (Images in SVG might cause issues)');
                })
                .finally(() => {
                    // Re-apply selection highlight if it was removed
                    if (selectedNode) selectedNode.classList.add('selected');
                });
        }
        
        // --- Save and Load Settings ---
        function saveSettings() {
            const settings = {
                verticalScaleFactor: verticalScaleFactor, // UPDATED: Save verticalScaleFactor
                imageSize: imageSize,
                fontSize: fontSize,
                fontColor: fontColor,
                fontBackgroundColor: fontBackgroundColor,
                fontFamily: fontFamily,
                boxColor: boxColor,
                boxLineColor: boxLineColor,
                lineColor: lineColor,
                lineThickness: lineThickness, // NEW: Save lineThickness
                boxRectWidth: boxRectWidth,
                boxRectHeight: boxRectHeight,
                boxShape: boxShape,
                treeBackgroundColor: treeBackgroundColor,
                verticalTextOffset: verticalTextOffset,
                textHorizontalOffset: textHorizontalOffset,
                showLifelines: showLifelines,
                showYearLines: showYearLines,
                rotationAngle: rotationAngle,
                treeScale: treeScale,
                backgroundImageUrl: backgroundImageUrl,
                backgroundSize: backgroundSize,
                backgroundPosX: backgroundPosX,
                backgroundPosY: backgroundPosY
            };
            const jsonString = JSON.stringify(settings, null, 2); // Pretty print JSON

            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
            const link = document.createElement('a');
            link.setAttribute('href', URL.createObjectURL(blob));
            link.setAttribute('download', 'family_tree_settings.json');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showMessage('Settings saved to JSON file!');
        }

        function handleLoadSettingsFile() {
            const fileInput = document.getElementById('loadSettingsFileInput');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('No settings file selected.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const settings = JSON.parse(e.target.result);
                    applySettings(settings);
                    showMessage('Settings loaded from JSON file!');
                } catch (error) {
                    console.error('Error parsing settings JSON:', error);
                    alert('Failed to load settings: Invalid JSON file.');
                }
            };
            reader.readAsText(file);
            fileInput.value = ''; // Clear the file input
        }

        function applySettings(settings) {
            verticalScaleFactor = settings.verticalScaleFactor !== undefined ? settings.verticalScaleFactor : 3; // UPDATED: Load verticalScaleFactor
            imageSize = settings.imageSize !== undefined ? settings.imageSize : 40;
            fontSize = settings.fontSize !== undefined ? settings.fontSize : 12;
            fontColor = settings.fontColor !== undefined ? settings.fontColor : '#f0f0f0';
            fontBackgroundColor = settings.fontBackgroundColor !== undefined ? settings.fontBackgroundColor : 'transparent';
            fontFamily = settings.fontFamily !== undefined ? settings.fontFamily : 'Arial, sans-serif';
            boxColor = settings.boxColor !== undefined ? settings.boxColor : '#444444';
            boxLineColor = settings.boxLineColor !== undefined ? settings.boxLineColor : '#ffa500';
            lineColor = settings.lineColor !== undefined ? settings.lineColor : '#ffa500';
            lineThickness = settings.lineThickness !== undefined ? settings.lineThickness : 2; // NEW: Load lineThickness
            boxRectWidth = settings.boxRectWidth !== undefined ? settings.boxRectWidth : 180;
            boxRectHeight = settings.boxRectHeight !== undefined ? settings.boxRectHeight : 180;
            boxShape = settings.boxShape !== undefined ? settings.boxShape : 'rectangle';
            treeBackgroundColor = settings.treeBackgroundColor !== undefined ? settings.treeBackgroundColor : '#2b2b2b';
            verticalTextOffset = settings.verticalTextOffset !== undefined ? settings.verticalTextOffset : 0;
            textHorizontalOffset = settings.textHorizontalOffset !== undefined ? settings.textHorizontalOffset : 0;
            showLifelines = settings.showLifelines !== undefined ? settings.showLifelines : false;
            showYearLines = settings.showYearLines !== undefined ? settings.showYearLines : true;
            rotationAngle = settings.rotationAngle !== undefined ? settings.rotationAngle : 0;
            treeScale = settings.treeScale !== undefined ? settings.treeScale : 1.0;
            backgroundImageUrl = settings.backgroundImageUrl !== undefined ? settings.backgroundImageUrl : null;
            backgroundSize = settings.backgroundSize !== undefined ? settings.backgroundSize : 100;
            backgroundPosX = settings.backgroundPosX !== undefined ? settings.backgroundPosX : 0;
            backgroundPosY = settings.backgroundPosY !== undefined ? settings.backgroundPosY : 0;

            // Update UI controls
            document.getElementById('verticalDistanceSlider').value = verticalScaleFactor; // UPDATED: Update slider
            document.getElementById('currentVerticalDistance').textContent = `${verticalScaleFactor.toFixed(1)}x`; // UPDATED: Update label
            document.getElementById('imageSizeInput').value = imageSize;
            document.getElementById('currentImageSize').textContent = `${imageSize}px`;
            document.getElementById('fontSizeSlider').value = fontSize;
            document.getElementById('currentFontSize').textContent = `${fontSize}px`;
            document.getElementById('fontColorPicker').value = fontColor;
            document.getElementById('fontBgColorPicker').value = fontBackgroundColor;
            // Update the color picker's value to transparent representation if fontBackgroundColor is 'transparent'
            if (fontBackgroundColor === 'transparent') {
                document.getElementById('fontBgColorPicker').value = '#00000000';
            } else {
                document.getElementById('fontBgColorPicker').value = fontBackgroundColor;
            }
            document.getElementById('fontFamilyInput').value = fontFamily;
            document.getElementById('boxColorPicker').value = boxColor;
            document.getElementById('boxLineColorPicker').value = boxLineColor;
            document.getElementById('lineColorPicker').value = lineColor;
            document.getElementById('lineThicknessSlider').value = lineThickness; // NEW: Update line thickness slider
            document.getElementById('currentLineThickness').textContent = `${lineThickness.toFixed(1)}px`; // NEW: Update line thickness label
            document.getElementById('boxRectWidthSlider').value = boxRectWidth;
            document.getElementById('currentBoxRectWidth').textContent = `${boxRectWidth}px`;
            document.getElementById('boxRectHeightSlider').value = boxRectHeight;
            document.getElementById('currentBoxRectHeight').textContent = `${boxRectHeight}px`;
            document.getElementById('boxShapeSelect').value = boxShape;
            document.getElementById('treeBgColorPicker').value = treeBackgroundColor;
            document.getElementById('verticalTextOffsetSlider').value = verticalTextOffset;
            document.getElementById('currentVerticalTextOffset').textContent = `${verticalTextOffset}px`;
            document.getElementById('textHorizontalOffsetSlider').value = textHorizontalOffset;
            document.getElementById('currentTextHorizontalOffset').textContent = `${textHorizontalOffset}px`;
            document.getElementById('treeScaleSlider').value = treeScale;
            document.getElementById('currentTreeScale').textContent = `${treeScale.toFixed(1)}x`;

            document.getElementById('bgSizeSlider').value = backgroundSize;
            document.getElementById('currentBgSize').textContent = `${backgroundSize}%`;
            document.getElementById('bgPosXSlider').value = backgroundPosX;
            document.getElementById('currentBgPosX').textContent = `${backgroundPosX}%`;
            document.getElementById('bgPosYSlider').value = backgroundPosY;
            document.getElementById('currentBgPosY').textContent = `${backgroundPosY}%`;
            document.getElementById('removeBgImageBtn').disabled = !backgroundImageUrl;

            // Apply styles and redraw
            updateBackgroundStyle();
            document.getElementById('treeContainer').style.backgroundColor = treeBackgroundColor; // Apply background color directly
            updateTreeScale(); // This will apply rotation too
            drawFamilyTree();
            document.getElementById('skinSelect').value = ''; // Reset skin dropdown after applying settings
        }

        // --- Collapse/Expand Control Sections ---
        function toggleSection(h3Element) {
            const controlSection = h3Element.closest('.control-section');
            if (controlSection) {
                controlSection.classList.toggle('collapsed');
            }
        }

        // --- Default background image loading ---
        async function loadDefaultBackgroundImage() {
            try {
                const response = await fetch('default.jpg');
                if (response.ok) {
                    const blob = await response.blob();
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        backgroundImageUrl = e.target.result;
                        updateBackgroundStyle();
                        document.getElementById('removeBgImageBtn').disabled = false;
                        showMessage('Default background image loaded.');
                    };
                    reader.readAsDataURL(blob);
                } else {
                    console.log('default.jpg not found or could not be loaded.');
                }
            } catch (error) {
                console.error('Error loading default.jpg:', error);
            }
        }


        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            // Set slider values and update displays
            document.getElementById('verticalDistanceSlider').value = verticalScaleFactor; // UPDATED
            document.getElementById('currentVerticalDistance').textContent = `${verticalScaleFactor.toFixed(1)}x`; // UPDATED
            
            document.getElementById('imageSizeInput').value = imageSize;
            document.getElementById('currentImageSize').textContent = `${imageSize}px`;

            // Initialize background image sliders and style
            document.getElementById('bgSizeSlider').value = backgroundSize;
            document.getElementById('currentBgSize').textContent = `${backgroundSize}%`;
            document.getElementById('bgPosXSlider').value = backgroundPosX;
            document.getElementById('currentBgPosX').textContent = `${backgroundPosX}%`;
            document.getElementById('bgPosYSlider').value = backgroundPosY;
            document.getElementById('currentBgPosY').textContent = `${backgroundPosY}%`;
            
            loadDefaultBackgroundImage(); // Loads default.jpg if exists (and calls updateBackgroundStyle)

            // Initialize tree scale slider
            document.getElementById('treeScaleSlider').value = treeScale;
            document.getElementById('currentTreeScale').textContent = `${treeScale.toFixed(1)}x`;
            updateTreeScale(); // Apply initial tree scale

            // Initialize customization controls
            document.getElementById('fontSizeSlider').value = fontSize;
            document.getElementById('currentFontSize').textContent = `${fontSize}px`;
            document.getElementById('fontColorPicker').value = fontColor;
            // Update the color picker's value to transparent representation if fontBackgroundColor is 'transparent'
            if (fontBackgroundColor === 'transparent') {
                document.getElementById('fontBgColorPicker').value = '#00000000';
            } else {
                document.getElementById('fontBgColorPicker').value = fontBackgroundColor;
            }
            document.getElementById('fontFamilyInput').value = fontFamily;
            document.getElementById('verticalTextOffsetSlider').value = verticalTextOffset;
            document.getElementById('currentVerticalTextOffset').textContent = `${verticalTextOffset}px`;
            document.getElementById('textHorizontalOffsetSlider').value = textHorizontalOffset;
            document.getElementById('currentTextHorizontalOffset').textContent = `${textHorizontalOffset}px`;
            document.getElementById('boxColorPicker').value = boxColor;
            document.getElementById('boxLineColorPicker').value = boxLineColor;
            document.getElementById('lineColorPicker').value = lineColor;
            document.getElementById('lineThicknessSlider').value = lineThickness; // NEW
            document.getElementById('currentLineThickness').textContent = `${lineThickness.toFixed(1)}px`; // NEW
            document.getElementById('boxRectWidthSlider').value = boxRectWidth;
            document.getElementById('currentBoxRectWidth').textContent = `${boxRectWidth}px`;
            document.getElementById('boxRectHeightSlider').value = boxRectHeight;
            document.getElementById('currentBoxRectHeight').textContent = `${boxRectHeight}px`;
            document.getElementById('boxShapeSelect').value = boxShape;
            document.getElementById('treeBgColorPicker').value = treeBackgroundColor;
            document.getElementById('treeContainer').style.backgroundColor = treeBackgroundColor;

            resetFormAndSelection();
            drawFamilyTree();

            // Collapse all control sections except the first one on initial load
            const controlSections = document.querySelectorAll('.control-section');
            controlSections.forEach((section, index) => {
                if (index > 0) { // Keep the first section open
                    section.classList.add('collapsed');
                }
            });
        });
    </script>
</body>
</html>
